diff -Naur a/include/governor.h b/include/governor.h
--- a/include/governor.h	1970-01-01 03:00:00.000000000 +0300
+++ b/include/governor.h	2014-10-08 10:33:54.989594520 +0300
@@ -0,0 +1,13 @@
+/*
+ * governor_pthread_wrapper.h
+ *
+ *  Created on: Sep 26, 2012
+ *      Author: alexey
+ */
+
+#ifndef GOVERNOR_PTHREAD_WRAPPER_H_
+#define GOVERNOR_PTHREAD_WRAPPER_H_
+
+#include <stdint.h>
+
+#endif /* GOVERNOR_PTHREAD_WRAPPER_H_ */
diff -Naur a/include/Makefile.am b/include/Makefile.am
--- a/include/Makefile.am	2013-11-04 20:52:27.000000000 +0200
+++ b/include/Makefile.am	2014-10-08 10:33:54.949594343 +0300
@@ -26,7 +26,7 @@
 			decimal.h errmsg.h my_global.h my_net.h \
 			my_getopt.h sslopt-longopts.h my_dir.h \
 			sslopt-vars.h sslopt-case.h sql_common.h keycache.h \
-			m_ctype.h my_attribute.h my_compiler.h \
+			m_ctype.h my_attribute.h my_compiler.h governor.h \
 			$(HEADERS_GEN_CONFIGURE) \
 			$(HEADERS_GEN_MAKE)
 
diff -Naur a/include/Makefile.in b/include/Makefile.in
--- a/include/Makefile.in	2013-11-04 20:54:59.000000000 +0200
+++ b/include/Makefile.in	2014-10-08 10:33:54.971594441 +0300
@@ -402,7 +402,7 @@
 			decimal.h errmsg.h my_global.h my_net.h \
 			my_getopt.h sslopt-longopts.h my_dir.h \
 			sslopt-vars.h sslopt-case.h sql_common.h keycache.h \
-			m_ctype.h my_attribute.h my_compiler.h \
+			m_ctype.h my_attribute.h my_compiler.h governor.h \
 			$(HEADERS_GEN_CONFIGURE) \
 			$(HEADERS_GEN_MAKE)
 
diff -Naur a/include/my_pthread.h b/include/my_pthread.h
--- a/include/my_pthread.h	2013-11-04 20:52:27.000000000 +0200
+++ b/include/my_pthread.h	2014-10-08 10:33:55.009594608 +0300
@@ -190,6 +190,7 @@
 #include <signal.h>
 #undef sigwait
 #endif
+#include <governor.h>
 #include <pthread.h>
 #ifndef _REENTRANT
 #define _REENTRANT
@@ -486,6 +487,13 @@
 } safe_mutex_info_t;
 #endif /* SAFE_MUTEX_DETECT_DESTROY */
 
+int put_in_lve(char *user);
+void lve_thr_exit();
+void governor_setlve_mysql_thread_info(pid_t thread_id);
+void governor_detroy_mysql_thread_info();
+__attribute__((noinline)) void my_release_slot();
+__attribute__((noinline)) void my_reserve_slot();
+
 int safe_mutex_init(safe_mutex_t *mp, const pthread_mutexattr_t *attr,
                     const char *file, uint line);
 int safe_mutex_lock(safe_mutex_t *mp, my_bool try_lock, const char *file, uint line);
@@ -501,6 +509,7 @@
 
 	/* Wrappers if safe mutex is actually used */
 #ifdef SAFE_MUTEX
+
 #undef pthread_mutex_init
 #undef pthread_mutex_lock
 #undef pthread_mutex_unlock
@@ -554,12 +563,23 @@
 #undef pthread_cond_timedwait
 #undef pthread_mutex_trylock
 #define pthread_mutex_init(A,B) my_pthread_fastmutex_init((A),(B))
-#define pthread_mutex_lock(A) my_pthread_fastmutex_lock(A)
-#define pthread_mutex_unlock(A) pthread_mutex_unlock(&(A)->mutex)
+
+int put_in_lve(char *user);
+void lve_thr_exit();
+void governor_setlve_mysql_thread_info(pid_t thread_id);
+void governor_detroy_mysql_thread_info();
+__attribute__ ((noinline)) int my_pthread_lvemutex_unlock(pthread_mutex_t *mutex);
+__attribute__ ((noinline)) int my_pthread_lvemutex_lock(my_pthread_fastmutex_t *mp);
+__attribute__ ((noinline)) int my_pthread_lvemutex_trylock(pthread_mutex_t *mp);
+__attribute__((noinline)) void my_release_slot();
+__attribute__((noinline)) void my_reserve_slot();
+#define pthread_mutex_lock(A) my_pthread_lvemutex_lock(A)
+#define pthread_mutex_unlock(A) my_pthread_lvemutex_unlock(&(A)->mutex)
+#define pthread_mutex_trylock(A) my_pthread_lvemutex_trylock(&(A)->mutex)
+
 #define pthread_mutex_destroy(A) pthread_mutex_destroy(&(A)->mutex)
 #define pthread_cond_wait(A,B) pthread_cond_wait((A),&(B)->mutex)
 #define pthread_cond_timedwait(A,B,C) pthread_cond_timedwait((A),&(B)->mutex,(C))
-#define pthread_mutex_trylock(A) pthread_mutex_trylock(&(A)->mutex)
 #define pthread_mutex_t my_pthread_fastmutex_t
 #endif /* defined(MY_PTHREAD_FASTMUTEX) && !defined(SAFE_MUTEX) */
 
diff -Naur a/mysys/mf_keycache.c b/mysys/mf_keycache.c
--- a/mysys/mf_keycache.c	2013-11-04 20:52:27.000000000 +0200
+++ b/mysys/mf_keycache.c	2014-10-08 12:26:06.240551574 +0300
@@ -2545,6 +2545,7 @@
   my_bool locked_and_incremented= FALSE;
   int error=0;
   uchar *start= buff;
+  my_reserve_slot();
   DBUG_ENTER("key_cache_read");
   DBUG_PRINT("enter", ("fd: %u  pos: %lu  length: %u",
                (uint) file, (ulong) filepos, length));
@@ -2734,6 +2735,7 @@
     dec_counter_for_resize_op(keycache);
     keycache_pthread_mutex_unlock(&keycache->cache_lock);
   }
+  my_release_slot();
   DBUG_PRINT("exit", ("error: %d", error ));
   DBUG_RETURN(error ? (uchar*) 0 : start);
 }
diff -Naur a/mysys/thr_mutex.c b/mysys/thr_mutex.c
--- a/mysys/thr_mutex.c	2013-11-04 20:52:27.000000000 +0200
+++ b/mysys/thr_mutex.c	2014-10-08 10:33:55.038594736 +0300
@@ -27,12 +27,48 @@
 #include "my_static.h"
 #include <m_string.h>
 
+void * (*governor_load_lve_library)() = NULL;
+int (*governor_init_lve)() = NULL;
+void (*governor_destroy_lve)() = NULL;
+int (*governor_enter_lve)(uint32_t *, char *) = NULL;
+void (*governor_lve_exit)(uint32_t *) = NULL;
+int (*governor_enter_lve_light)(uint32_t *) = NULL;
+void (*governor_lve_exit_null)() = NULL;
+int (*governor_lve_enter_pid)(pid_t) = NULL;
+ 
+void governor_setlve_mysql_thread_info(pid_t thread_id) {
+	thread_id = 0;
+	return;
+}
+
+__attribute__((noinline)) int put_in_lve(char *user) {
+	user = NULL;
+	return 0;
+}
+
+__attribute__((noinline)) void lve_thr_exit() {
+	return;
+}
+
+void governor_detroy_mysql_thread_info(){
+	return;
+}
+
+__attribute__((noinline)) void my_release_slot(){
+    return;
+}
+
+__attribute__((noinline)) void my_reserve_slot(){
+    return;
+}
+
 #ifndef DO_NOT_REMOVE_THREAD_WRAPPERS
 /* Remove wrappers */
 #undef pthread_mutex_t
 #undef pthread_mutex_init
 #undef pthread_mutex_lock
 #undef pthread_mutex_unlock
+#undef pthread_mutex_trylock
 #undef pthread_mutex_destroy
 #undef pthread_cond_wait
 #undef pthread_cond_timedwait
@@ -396,6 +432,8 @@
 
 #if defined(THREAD) && defined(MY_PTHREAD_FASTMUTEX) && !defined(SAFE_MUTEX)
 
+#include <linux/unistd.h>
+
 #include "mysys_priv.h"
 #include "my_static.h"
 #include <m_string.h>
@@ -489,6 +527,298 @@
   return pthread_mutex_lock(&mp->mutex);
 }
 
+void * (*governor_load_lve_library)() = NULL;
+int (*governor_init_lve)() = NULL;
+void (*governor_destroy_lve)() = NULL;
+int (*governor_enter_lve)(uint32_t *, char *) = NULL;
+void (*governor_lve_exit)(uint32_t *) = NULL;
+int (*governor_enter_lve_light)(uint32_t *) = NULL;
+void (*governor_lve_exit_null)() = NULL;
+int (*governor_lve_enter_pid)(pid_t) = NULL;
+
+extern CHARSET_INFO my_charset_latin1_bin;
+CHARSET_INFO governor_charset_bin;
+
+__thread uint32_t lve_cookie = 0;
+
+pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
+
+typedef struct __mysql_mutex {
+	pid_t *key;
+	int is_in_lve;
+	int is_in_mutex;
+	int put_in_lve;
+} mysql_mutex;
+
+static HASH *mysql_lve_mutex_governor = NULL;
+
+__thread mysql_mutex *mysql_lve_mutex_governor_ptr = 0;
+
+pthread_mutex_t mtx_mysql_lve_mutex_governor_ptr = PTHREAD_MUTEX_INITIALIZER;
+
+void governor_value_destroyed(mysql_mutex *data) {
+	free(data);
+}
+
+uchar *governor_get_key_table_mutex(mysql_mutex *table_mutex, size_t *length,
+		my_bool not_used __attribute__((unused))) {
+	*length = sizeof(table_mutex->key);
+	return (uchar*) table_mutex->key;
+}
+
+/*
+ *   RETURN
+ * < 0	s < t
+ * 0	s == t
+ * > 0	s > t
+ */
+static int governor_my_strnncoll_8bit_bin(CHARSET_INFO * cs __attribute__((unused)), const uchar *s,
+		size_t slen, const uchar *t, size_t tlen, my_bool t_is_prefix) {
+	int res = 0;
+	pid_t s1 = (pid_t)s, t1 = (pid_t)t;
+	if (s1 < t1)
+		res = -1;
+	else if (s1 == t1)
+		res = 0;
+	else
+		res = 1;
+	return res;
+}
+
+void governor_hash_sort_8bit_bin(CHARSET_INFO *cs __attribute__((unused)),
+                           const uchar *key, size_t len,
+                           ulong *nr1, ulong *nr2)
+{
+  return;
+}
+
+HASH *governor_create_hash_table() {
+	mysql_lve_mutex_governor = (HASH *) calloc(1, sizeof(HASH));
+	if (mysql_lve_mutex_governor) {
+		memcpy(&governor_charset_bin, &my_charset_latin1_bin,
+				sizeof(CHARSET_INFO));
+		governor_charset_bin.coll->strnncoll = governor_my_strnncoll_8bit_bin;
+		governor_charset_bin.coll->hash_sort = governor_hash_sort_8bit_bin;
+		if (hash_init(mysql_lve_mutex_governor, &governor_charset_bin, 500, 0,
+				0, (hash_get_key) governor_get_key_table_mutex,
+				(hash_free_key) governor_value_destroyed, 0)) {
+			mysql_lve_mutex_governor = NULL;
+		}
+	}
+	return mysql_lve_mutex_governor;
+}
+
+int governor_add_mysql_thread_info() {
+	pid_t *buf = NULL;
+	pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+	mysql_mutex *mm = NULL;
+	if (!mysql_lve_mutex_governor) {
+		mysql_lve_mutex_governor = governor_create_hash_table();
+		if (!mysql_lve_mutex_governor){
+			pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+			return -1;
+		}
+	}
+	buf = (pid_t *)syscall(__NR_gettid);
+	mm = (mysql_mutex *) hash_search(mysql_lve_mutex_governor,
+			(uchar *) buf, sizeof(buf));
+	if (!mm) {
+		mm = (mysql_mutex *) calloc(1, sizeof(mysql_mutex));
+		if (!mm)
+			return -1;
+		mm->key = (pid_t *)syscall(__NR_gettid);
+		if (hash_insert(mysql_lve_mutex_governor, (uchar *) mm)) {
+			free(mm);
+			pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+			return -1;
+		}
+	}
+	pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+	mysql_lve_mutex_governor_ptr = mm;
+	return 0;
+}
+
+void governor_remove_mysql_thread_info() {
+	pid_t *buf = NULL;
+	pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+	mysql_mutex *mm = NULL;
+	if (mysql_lve_mutex_governor) {
+		buf = (pid_t *)syscall(__NR_gettid);
+		mm = (mysql_mutex *) hash_search(mysql_lve_mutex_governor,
+				(uchar *) buf, sizeof(buf));
+		if (mm)
+			hash_delete(mysql_lve_mutex_governor, (uchar *) mm);
+	}
+	pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+	mysql_lve_mutex_governor_ptr = NULL;
+}
+
+void governor_setlve_mysql_thread_info(pid_t thread_id) {
+	pid_t *buf = NULL;
+	pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+	mysql_mutex *mm = NULL;
+	if (mysql_lve_mutex_governor) {
+		buf = (pid_t *)thread_id;
+		mm = (mysql_mutex *) hash_search(mysql_lve_mutex_governor,
+				(uchar *) buf, sizeof(buf));
+		if (mm) {
+			if (!mm->is_in_lve) {
+				mm->put_in_lve = 1;
+				//if (mm->is_in_mutex) {
+				//	mm->put_in_lve = 1;
+				//} else {
+				//	mm->put_in_lve = 1;
+				//	governor_lve_enter_pid(thread_id);
+				//}
+			}
+		}
+	}
+	pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+}
+
+void governor_detroy_mysql_thread_info() {
+	if (mysql_lve_mutex_governor) {
+		pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+		hash_free(mysql_lve_mutex_governor);
+		free(mysql_lve_mutex_governor);
+		pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+	}
+}
+
+__attribute__((noinline)) int put_in_lve(char *user) {
+	if (governor_add_mysql_thread_info()<0) return -1;
+	if (mysql_lve_mutex_governor_ptr) {
+		if (!governor_enter_lve(&lve_cookie, user)) {
+			mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+		}
+		mysql_lve_mutex_governor_ptr->is_in_mutex = 0;
+	}
+	return 0;
+}
+
+__attribute__((noinline)) void lve_thr_exit() {
+	if (mysql_lve_mutex_governor_ptr && mysql_lve_mutex_governor_ptr->is_in_lve
+			== 1) {
+		governor_lve_exit(&lve_cookie);
+		mysql_lve_mutex_governor_ptr->is_in_lve = 0;
+	}
+	governor_remove_mysql_thread_info();
+}
+
+__attribute__((noinline)) int my_pthread_lvemutex_lock(my_pthread_fastmutex_t *mp) {
+	if (mysql_lve_mutex_governor_ptr) {
+		if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+			governor_lve_exit(&lve_cookie);
+			mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+		} else if (mysql_lve_mutex_governor_ptr->is_in_lve > 1) {
+			mysql_lve_mutex_governor_ptr->is_in_lve++;
+		} /*else if (mysql_lve_mutex_governor_ptr->put_in_lve
+				&& !mysql_lve_mutex_governor_ptr->is_in_mutex) {
+			//governor_lve_exit_null();
+			mysql_lve_mutex_governor_ptr->put_in_lve = 0;
+			mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+		}*/
+		mysql_lve_mutex_governor_ptr->is_in_mutex++;
+	}
+	return my_pthread_fastmutex_lock(mp);
+}
+
+
+__attribute__((noinline)) int my_pthread_lvemutex_trylock(pthread_mutex_t *mp) {
+       if (mysql_lve_mutex_governor_ptr) {
+               if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+                       governor_lve_exit(&lve_cookie);
+               }
+       }
+       int ret = pthread_mutex_trylock(mp);
+       if (mysql_lve_mutex_governor_ptr) {
+           if (ret != EBUSY){
+                if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+                } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve++;
+                }
+                mysql_lve_mutex_governor_ptr->is_in_mutex++;
+               } else {
+                if (mysql_lve_mutex_governor_ptr->is_in_lve == 1){
+                    if (!governor_enter_lve_light(&lve_cookie)) {
+                           mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                    } else {
+    			   mysql_lve_mutex_governor_ptr->is_in_lve = 0;
+                    }
+                }
+               }
+       }
+       return ret;
+}
+
+
+__attribute__((noinline)) int my_pthread_lvemutex_unlock(
+		pthread_mutex_t *mutex) {
+	int ret = pthread_mutex_unlock(mutex);
+	if (mysql_lve_mutex_governor_ptr) {
+		if ((mysql_lve_mutex_governor_ptr->is_in_lve == 2)
+				&& governor_enter_lve_light) {
+			if (!governor_enter_lve_light(&lve_cookie)) {
+				mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+			}
+		} else if (mysql_lve_mutex_governor_ptr->is_in_lve > 2) {
+			mysql_lve_mutex_governor_ptr->is_in_lve--;
+		}
+		mysql_lve_mutex_governor_ptr->is_in_mutex--;
+		/*if (mysql_lve_mutex_governor_ptr->put_in_lve
+				&& !mysql_lve_mutex_governor_ptr->is_in_mutex) {
+			if (governor_enter_lve_light && !governor_enter_lve_light(
+					&lve_cookie)) {
+				mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+				mysql_lve_mutex_governor_ptr->put_in_lve = 0;
+			}
+		}*/
+	}
+	return ret;
+}
+
+__attribute__((noinline)) void my_reserve_slot() {
+       if (mysql_lve_mutex_governor_ptr) {
+               if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+                       governor_lve_exit(&lve_cookie);
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+               } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve++;
+               } /*else if (mysql_lve_mutex_governor_ptr->put_in_lve
+                               && !mysql_lve_mutex_governor_ptr->is_in_mutex) {
+                       //governor_lve_exit_null();
+                       mysql_lve_mutex_governor_ptr->put_in_lve = 0;
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+               }*/
+               mysql_lve_mutex_governor_ptr->is_in_mutex++;
+       }
+       return;
+}
+
+__attribute__((noinline)) void my_release_slot() {
+       if (mysql_lve_mutex_governor_ptr) {
+               if ((mysql_lve_mutex_governor_ptr->is_in_lve == 2)
+                               && governor_enter_lve_light) {
+                       if (!governor_enter_lve_light(&lve_cookie)) {
+                               mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                       }
+               } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 2) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve--;
+               }
+               mysql_lve_mutex_governor_ptr->is_in_mutex--;
+               /*if (mysql_lve_mutex_governor_ptr->put_in_lve
+                               && !mysql_lve_mutex_governor_ptr->is_in_mutex) {
+                       if (governor_enter_lve_light && !governor_enter_lve_light(
+                                       &lve_cookie)) {
+                               mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                               mysql_lve_mutex_governor_ptr->put_in_lve = 0;
+                       }
+               }*/
+       }
+       return;
+}
+
 
 void fastmutex_global_init(void)
 {
@@ -498,3 +828,47 @@
 }
   
 #endif /* defined(THREAD) && defined(MY_PTHREAD_FASTMUTEX) && !defined(SAFE_MUTEX) */ 
+
+#if !defined(MY_PTHREAD_FASTMUTEX) && !defined(SAFE_MUTEX) 
+
+#include "mysys_priv.h"
+#include "my_static.h"
+#include <m_string.h>
+#include "governor.h"
+
+void * (*governor_load_lve_library)() = NULL;
+int (*governor_init_lve)() = NULL;
+void (*governor_destroy_lve)() = NULL;
+int (*governor_enter_lve)(uint32_t *, char *) = NULL;
+void (*governor_lve_exit)(uint32_t *) = NULL;
+int (*governor_enter_lve_light)(uint32_t *) = NULL;
+void (*governor_lve_exit_null)() = NULL;
+int (*governor_lve_enter_pid)(pid_t) = NULL;
+ 
+void governor_setlve_mysql_thread_info(pid_t thread_id) {
+	thread_id = 0;
+	return;
+}
+
+__attribute__((noinline)) int put_in_lve(char *user) {
+	user = NULL;
+	return 0;
+}
+
+__attribute__((noinline)) void lve_thr_exit() {
+	return;
+}
+
+void governor_detroy_mysql_thread_info(){
+	return;
+}
+
+__attribute__((noinline)) void my_reserve_slot() {
+       return;
+}
+
+__attribute__((noinline)) void my_release_slot() {
+       return;
+}
+
+#endif
diff -Naur a/sql/handler.cc b/sql/handler.cc
--- a/sql/handler.cc	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/handler.cc	2014-10-08 10:33:55.060594834 +0300
@@ -1364,6 +1364,7 @@
 int ha_autocommit_or_rollback(THD *thd, int error)
 {
   DBUG_ENTER("ha_autocommit_or_rollback");
+  my_reserve_slot();
 #ifdef USING_TRANSACTIONS
   if (thd->transaction.stmt.ha_list)
   {
@@ -1382,6 +1383,7 @@
     thd->variables.tx_isolation=thd->session_tx_isolation;
   }
 #endif
+  my_release_slot();
   DBUG_RETURN(error);
 }
 
diff -Naur a/sql/lex.h b/sql/lex.h
--- a/sql/lex.h	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/lex.h	2014-10-08 10:33:55.083594935 +0300
@@ -183,6 +183,10 @@
   { "ELSE",             SYM(ELSE)},
   { "ELSEIF",           SYM(ELSEIF_SYM)},
   { "ENABLE",		SYM(ENABLE_SYM)},
+  { "ENABLE_GOVERNOR",		SYM(ENABLE_GOVERNOR_SYM)},
+  { "ENABLE_GOVERNOR_RECON",		SYM(ENABLE_GOVERNOR_RECONN_SYM)},
+  { "ENABLE_GOVERNOR_LVE",		SYM(ENABLE_GOVERNOR_LVE_SYM)},
+  { "ENABLE_GOVERNOR_RECON_LVE",		SYM(ENABLE_GOVERNOR_RECONN_LVE_SYM)},
   { "ENCLOSED",		SYM(ENCLOSED)},
   { "END",		SYM(END)},
   { "ENDS",		SYM(ENDS_SYM)},
@@ -307,6 +311,7 @@
   { "LONGTEXT",		SYM(LONGTEXT)},
   { "LOOP",             SYM(LOOP_SYM)},
   { "LOW_PRIORITY",	SYM(LOW_PRIORITY)},
+  { "LVECMD",		SYM(LVECMD_SYM)},
   { "MASTER",           SYM(MASTER_SYM)},
   { "MASTER_CONNECT_RETRY",           SYM(MASTER_CONNECT_RETRY_SYM)},
   { "MASTER_HOST",           SYM(MASTER_HOST_SYM)},
diff -Naur a/sql/mysqld.cc b/sql/mysqld.cc
--- a/sql/mysqld.cc	2014-10-08 10:31:34.304986952 +0300
+++ b/sql/mysqld.cc	2014-10-08 10:33:55.130595145 +0300
@@ -29,6 +29,7 @@
 #include "events.h"
 #include "debug_sync.h"
 #include "log_event.h"
+#include <dlfcn.h>
 
 #include "../storage/myisam/ha_myisam.h"
 
@@ -57,6 +58,8 @@
 #include "sp_rcontext.h"
 #include "sp_cache.h"
 
+#include <linux/unistd.h>
+
 #define mysqld_charset &my_charset_latin1
 
 #ifdef HAVE_purify
@@ -263,6 +266,10 @@
 #include <my_pthread.h>			// For thr_setconcurency()
 #endif
 
+#ifndef GETTID
+pid_t gettid(void) {return syscall(__NR_gettid);}
+#endif
+
 #ifdef SOLARIS
 extern "C" int gethostname(char *name, int namelen);
 #endif
@@ -450,6 +457,30 @@
 
 /* Global variables */
 
+#ifdef  __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+extern void * (*governor_load_lve_library)();
+extern int (*governor_init_lve)();
+extern void (*governor_destroy_lve)();
+extern int (*governor_enter_lve)(uint32_t *, char *);
+extern int (*governor_enter_lve_light)(uint32_t *);
+extern void (*governor_lve_exit)(uint32_t *);
+extern void (*governor_lve_exit_null)();
+extern int (*governor_lve_enter_pid)(pid_t);
+
+#ifdef  __cplusplus
+}
+#endif
+
+volatile int governor_get_command = 0;
+int (*connect_to_server)() = NULL;
+int (*send_info_begin)(char *) = NULL;
+int (*send_info_end)(char *) = NULL;
+int (*close_sock)() = NULL;
+void * governor_library_handle = NULL;
+
 bool opt_update_log, opt_bin_log, opt_ignore_builtin_innodb= 0;
 my_bool opt_log, opt_slow_log;
 ulong log_output_options;
@@ -1323,6 +1354,19 @@
   injector::free_instance();
   mysql_bin_log.cleanup();
 
+  governor_detroy_mysql_thread_info();
+
+  if(governor_destroy_lve){
+	  governor_destroy_lve();
+  }
+
+  if(close_sock){
+	  (*close_sock)();
+  }
+  if (governor_library_handle) {
+	  dlclose(governor_library_handle);
+  }
+
 #ifdef HAVE_REPLICATION
   if (use_slave_mask)
     bitmap_free(&slave_error_mask);
@@ -3064,6 +3108,10 @@
   {"drop_user",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_USER]), SHOW_LONG_STATUS},
   {"drop_view",            (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_DROP_VIEW]), SHOW_LONG_STATUS},
   {"empty_query",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EMPTY_QUERY]), SHOW_LONG_STATUS},
+  {"enable_governor",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ENABLE_GOVERNOR]), SHOW_LONG_STATUS},
+  {"enable_governor_reconn",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ENABLE_RECONN_GOVERNOR]), SHOW_LONG_STATUS},
+  {"enable_governor_lve",      (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ENABLE_GOVERNOR_LVE]), SHOW_LONG_STATUS},
+  {"enable_governor_reconn_lve",(char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_ENABLE_RECONN_GOVERNOR_LVE]), SHOW_LONG_STATUS},
   {"execute_sql",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_EXECUTE]), SHOW_LONG_STATUS},
   {"flush",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_FLUSH]), SHOW_LONG_STATUS},
   {"grant",                (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_GRANT]), SHOW_LONG_STATUS},
@@ -3079,6 +3127,7 @@
   {"load_master_data",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOAD_MASTER_DATA]), SHOW_LONG_STATUS},
   {"load_master_table",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOAD_MASTER_TABLE]), SHOW_LONG_STATUS},
   {"lock_tables",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOCK_TABLES]), SHOW_LONG_STATUS},
+  {"lvecmd",                  (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LVECMD]), SHOW_LONG_STATUS},
   {"optimize",             (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_OPTIMIZE]), SHOW_LONG_STATUS},
   {"preload_keys",         (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PRELOAD_KEYS]), SHOW_LONG_STATUS},
   {"prepare_sql",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PREPARE]), SHOW_LONG_STATUS},
@@ -7561,6 +7610,7 @@
   {"Delayed_errors",           (char*) &delayed_insert_errors,  SHOW_LONG},
   {"Delayed_insert_threads",   (char*) &delayed_insert_threads, SHOW_LONG_NOFLUSH},
   {"Delayed_writes",           (char*) &delayed_insert_writes,  SHOW_LONG},
+  {"Enable_governor",           (char*) &governor_get_command,  SHOW_INT},
   {"Flush_commands",           (char*) &refresh_version,        SHOW_LONG_NOFLUSH},
   {"Handler_commit",           (char*) offsetof(STATUS_VAR, ha_commit_count), SHOW_LONG_STATUS},
   {"Handler_delete",           (char*) offsetof(STATUS_VAR, ha_delete_count), SHOW_LONG_STATUS},
@@ -7748,6 +7798,24 @@
     as these are initialized by my_getopt.
 */
 
+void governor_set_fn_ptr_to_null(){
+	governor_load_lve_library = NULL;
+	governor_init_lve = NULL;
+	governor_destroy_lve = NULL;
+	governor_enter_lve = NULL;
+	governor_lve_exit = NULL;
+	governor_enter_lve_light = NULL;
+	governor_lve_exit_null = NULL;
+	governor_lve_enter_pid = NULL;
+}
+
+void governor_set_fn2_ptr_to_null(){
+	connect_to_server = NULL;
+	send_info_begin = NULL;
+	send_info_end = NULL;
+	close_sock = NULL;
+}
+
 static int mysql_init_variables(void)
 {
   int error;
@@ -7882,6 +7950,112 @@
   global_system_variables.old_passwords= 0;
   global_system_variables.old_alter_table= 0;
   global_system_variables.binlog_format= BINLOG_FORMAT_UNSPEC;
+
+  governor_get_command = 0;
+  connect_to_server = NULL;
+  send_info_begin = NULL;
+  send_info_end = NULL;
+  close_sock = NULL;
+  governor_library_handle = NULL;
+
+  char *error_dl = NULL;
+  governor_library_handle = dlopen("libgovernor.so", RTLD_LAZY);
+  if (governor_library_handle) {
+	  sql_print_information("libgovernor.so found");
+	  while(1){
+		  connect_to_server = (int (*)())dlsym(governor_library_handle, "connect_to_server");
+		  if ((error_dl = dlerror()) != NULL){
+			  governor_set_fn2_ptr_to_null();
+			  break;
+		  }
+		  send_info_begin = (int (*)(char *))dlsym(governor_library_handle, "send_info_begin");
+		  if ((error_dl = dlerror()) != NULL){
+			  governor_set_fn2_ptr_to_null();
+		  	  break;
+		  }
+		  send_info_end = (int (*)(char *))dlsym(governor_library_handle, "send_info_end");
+		  if ((error_dl = dlerror()) != NULL){
+			  governor_set_fn2_ptr_to_null();
+			  break;
+		  }
+		  close_sock = (int (*)())dlsym(governor_library_handle, "close_sock");
+		  if ((error_dl = dlerror()) != NULL){
+			  governor_set_fn2_ptr_to_null();
+			  break;
+	  }
+		  sql_print_information("All governors functions found too");
+		  break;
+	  }
+  } else {
+	  sql_print_information("libgovernor.so not found");
+  }
+  if(connect_to_server){
+	  if(!(*connect_to_server)()){
+		  sql_print_information("Governor connected");
+	  } else {
+		  sql_print_error("Governor not connected");
+	  }
+  }
+  if (governor_library_handle){
+
+	  while(1){
+		  governor_load_lve_library = (void * (*)())dlsym(governor_library_handle, "governor_load_lve_library");
+	  	  if ((error_dl = dlerror()) != NULL){
+	  		governor_set_fn_ptr_to_null();
+	  		break;
+	  	  }
+	  	  governor_init_lve = (int (*)())dlsym(governor_library_handle, "governor_init_lve");
+	  	  if ((error_dl = dlerror()) != NULL){
+	  		governor_set_fn_ptr_to_null();
+	  		break;
+	  	  }
+	  	  governor_destroy_lve = (void (*)())dlsym(governor_library_handle, "governor_destroy_lve");
+	  	  if ((error_dl = dlerror()) != NULL){
+   		    governor_set_fn_ptr_to_null();
+	  	    break;
+	  	  }
+	  	  governor_enter_lve = (int (*)(uint32_t *, char *))dlsym(governor_library_handle, "governor_enter_lve");
+	  	  if ((error_dl = dlerror()) != NULL){
+	  		governor_set_fn_ptr_to_null();
+	  		break;
+	  	  }
+
+	  	  governor_lve_exit = (void (*)(uint32_t *))dlsym(governor_library_handle, "governor_lve_exit");
+	  	  if ((error_dl = dlerror()) != NULL){
+	  		governor_set_fn_ptr_to_null();
+	  		break;
+	  	  }
+
+	  	  governor_enter_lve_light = (int (*)(uint32_t *))dlsym(governor_library_handle, "governor_enter_lve_light");
+	  	  if ((error_dl = dlerror()) != NULL){
+	  		governor_set_fn_ptr_to_null();
+	  		break;
+	  	  }
+
+	  	  governor_lve_exit_null = (void (*)(void))dlsym(governor_library_handle, "governor_lve_exit_null");
+	  	  if ((error_dl = dlerror()) != NULL){
+	  		governor_set_fn_ptr_to_null();
+	  		break;
+	  	  }
+
+	  	  governor_lve_enter_pid = (int (*)(pid_t))dlsym(governor_library_handle, "governor_lve_enter_pid");
+	  	  if ((error_dl = dlerror()) != NULL){
+	  		governor_set_fn_ptr_to_null();
+	  		break;
+	  	  }
+
+	  	  sql_print_information("All governors lve functions found too");
+	  	  break;
+	   }
+
+  }
+
+  if(governor_load_lve_library){
+	  if(!governor_load_lve_library()){
+		  sql_print_information("Can't get LVE functions");
+	  }
+  }
+
   /*
     Default behavior for 4.1 and 5.0 is to treat NULL values as unequal
     when collecting index statistics for MyISAM tables.
@@ -8808,6 +8982,7 @@
 #endif
   if (opt_log || opt_update_log || opt_slow_log || opt_bin_log)
     strmov(end, "-log");                        // This may slow down system
+  end= strmov(end, "-cll-lve");
 }
 
 
@@ -9165,7 +9340,7 @@
   File file;
   if (opt_bootstrap ||
       !pid_file_created ||
-      !(file= my_open(pidfile_name, O_RDONLY, flags)))
+      ((file= my_open(pidfile_name, O_RDONLY, flags))<0))
     return;
 
   /* Make sure that the pid file was created by the same process. */
diff -Naur a/sql/mysql_priv.h b/sql/mysql_priv.h
--- a/sql/mysql_priv.h	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/mysql_priv.h	2014-10-08 10:38:41.462910985 +0300
@@ -103,8 +103,12 @@
 			       CHARSET_INFO *from_cs,
 			       size_t max_res_length,
 			       CHARSET_INFO *to_cs, size_t *result_length);
+uint kill_user_thread(THD *thd, char *user, bool only_kill_query);
+uint kill_user_thread_lve(THD *thd, char *user, bool only_kill_query);
 uint kill_one_thread(THD *thd, ulong id, bool only_kill_query);
 void sql_kill(THD *thd, ulong id, bool only_kill_query);
+void sql_kill_user(THD *thd, char *user, bool only_kill_query);
+void sql_kill_user_lve(THD *thd, char *user, bool only_kill_query);
 bool net_request_file(NET* net, const char* fname);
 char* query_table_status(THD *thd,const char *db,const char *table_name);
 
@@ -1450,6 +1454,10 @@
 ST_SCHEMA_TABLE *get_schema_table(enum enum_schema_tables schema_table_idx);
 int prepare_schema_table(THD *thd, LEX *lex, Table_ident *table_ident,
                          enum enum_schema_tables schema_table_idx);
+void set_governor_variable();
+void set_governor_variable_reconn();
+void set_governor_variable_lve();
+void set_governor_variable_reconn_lve();
 int make_schema_select(THD *thd,  SELECT_LEX *sel,
                        enum enum_schema_tables schema_table_idx);
 int mysql_schema_table(THD *thd, LEX *lex, TABLE_LIST *table_list);
@@ -2022,6 +2030,13 @@
 extern ulong opt_tc_log_size, tc_log_max_pages_used, tc_log_page_size;
 extern ulong tc_log_page_waits;
 extern my_bool relay_log_purge, opt_innodb_safe_binlog, opt_innodb;
+extern volatile int governor_get_command;
+extern int (*connect_to_server)();
+extern int (*send_info_begin)(char *);
+extern int (*send_info_end)(char *);
+extern int (*close_sock)();
+extern void * governor_library_handle;
+
 extern uint test_flags,select_errors,ha_open_options;
 extern uint protocol_version, mysqld_port, dropping_tables;
 extern uint delay_key_write_options;
@@ -2391,6 +2406,7 @@
 /* sql_list.cc */
 void free_list(I_List <i_string_pair> *list);
 void free_list(I_List <i_string> *list);
+void free_list(I_List <i_thd> *list);
 
 /* sql_yacc.cc */
 #ifndef DBUG_OFF
@@ -2610,6 +2626,8 @@
                     CHARSET_INFO *dflt_cl,
                     CHARSET_INFO **cl);
 
+extern "C" pid_t gettid(void);
+
 #endif /* MYSQL_SERVER */
 extern "C" int test_if_data_home_dir(const char *dir);
 
diff -Naur a/sql/sql_acl.cc b/sql/sql_acl.cc
--- a/sql/sql_acl.cc	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/sql_acl.cc	2014-10-08 12:32:55.968099338 +0300
@@ -539,7 +539,7 @@
         {
           /* Starting from 5.0.3 we have max_user_connections field */
           ptr= get_field(thd->mem_root, table->field[next_field++]);
-          user.user_resource.user_conn= ptr ? atoi(ptr) : 0;
+          user.user_resource.user_conn= ptr ? atoll(ptr) : 0;
         }
         else
           user.user_resource.user_conn= 0;
diff -Naur a/sql/sql_class.cc b/sql/sql_class.cc
--- a/sql/sql_class.cc	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/sql_class.cc	2014-10-08 10:33:55.173595335 +0300
@@ -631,7 +631,8 @@
 #endif /* defined(ENABLED_DEBUG_SYNC) */
 {
   ulong tmp;
-
+  thread_tid_cll = 0;
+  
   /*
     Pass nominal parameters to init_alloc_root only to ensure that
     the destructor works OK in case of an error. The main_mem_root
@@ -895,6 +896,7 @@
 
 void THD::init_for_queries()
 {
+  thread_tid_cll = gettid();
   set_time(); 
   ha_enable_transaction(this,TRUE);
 
diff -Naur a/sql/sql_class.h b/sql/sql_class.h
--- a/sql/sql_class.h	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/sql_class.h	2014-10-08 10:33:55.192595418 +0300
@@ -1798,6 +1798,7 @@
   */
   ulong      row_count;
   pthread_t  real_id;                           /* For debugging */
+  pid_t      thread_tid_cll;
   my_thread_id  thread_id;
   uint	     tmp_table, global_read_lock;
   uint	     server_status,open_options;
@@ -3156,3 +3157,13 @@
 void mark_transaction_to_rollback(THD *thd, bool all);
 
 #endif /* MYSQL_SERVER */
+
+/* DB_GOVERNOR ADDITIONS */                                                                                                                               
+class i_thd: public ilink                                                                                                                                 
+{                                                                                                                                                         
+ public:                                                                                                                                                   
+   THD* ptr;                                                                                                                                               
+   i_thd():ptr(0) { }                                                                                                                                      
+   i_thd(THD* s) : ptr(s) {}                                                                                                                               
+};                                                                                                                                                        
+   
diff -Naur a/sql/sql_connect.cc b/sql/sql_connect.cc
--- a/sql/sql_connect.cc	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/sql_connect.cc	2014-10-08 12:49:31.131968727 +0300
@@ -104,7 +104,7 @@
     0	ok
     1	error
 */
-
+ 
 static
 int check_for_max_user_connections(THD *thd, USER_CONN *uc)
 {
@@ -112,6 +112,7 @@
   DBUG_ENTER("check_for_max_user_connections");
 
   (void) pthread_mutex_lock(&LOCK_user_conn);
+
   if (max_user_connections && !uc->user_resources.user_conn &&
       max_user_connections < (uint) uc->connections)
   {
@@ -432,8 +433,8 @@
 
       /* Don't allow user to connect if he has done too many queries */
       if ((ur.questions || ur.updates || ur.conn_per_hour || ur.user_conn ||
-	   max_user_connections) &&
-	  get_or_create_user_conn(thd,
+           max_user_connections) &&
+         get_or_create_user_conn(thd,
             (opt_old_style_user_limits ? thd->main_security_ctx.user :
              thd->main_security_ctx.priv_user),
             (opt_old_style_user_limits ? thd->main_security_ctx.host_or_ip :
@@ -1453,6 +1454,7 @@
 pthread_handler_t handle_one_connection(void *arg)
 {
   THD *thd= (THD*) arg;
+  thd->thread_tid_cll = gettid();
 
   thd->thr_create_utime= my_micro_time();
 
diff -Naur a/sql/sql_lex.h b/sql/sql_lex.h
--- a/sql/sql_lex.h	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/sql_lex.h	2014-10-08 10:40:39.311474175 +0300
@@ -125,6 +125,8 @@
   SQLCOM_SHOW_CREATE_TRIGGER,
   SQLCOM_ALTER_DB_UPGRADE,
   SQLCOM_SHOW_PROFILE, SQLCOM_SHOW_PROFILES,
+  SQLCOM_ENABLE_GOVERNOR, SQLCOM_ENABLE_RECONN_GOVERNOR,
+  SQLCOM_ENABLE_GOVERNOR_LVE, SQLCOM_ENABLE_RECONN_GOVERNOR_LVE, SQLCOM_LVECMD,
 
   /*
     When a command is added here, be sure it's also added in mysqld.cc
diff -Naur a/sql/sql_list.cc b/sql/sql_list.cc
--- a/sql/sql_list.cc	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/sql_list.cc	2014-10-08 10:33:55.255595698 +0300
@@ -70,3 +70,10 @@
   first= &end_of_list;
   last= &first;
 }
+
+void free_list(I_List <i_thd> *list)
+{
+  i_thd *tmp;
+  while ((tmp= list->get()))
+    delete tmp;
+}
diff -Naur a/sql/sql_parse.cc b/sql/sql_parse.cc
--- a/sql/sql_parse.cc	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/sql_parse.cc	2014-10-08 11:31:07.239995251 +0300
@@ -14,7 +14,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
 */
-
+#define HAVE_CLOCK_GETTIME 1
 #define MYSQL_LEX 1
 #include "mysql_priv.h"
 #include "sql_repl.h"
@@ -31,6 +31,21 @@
 #include "sql_trigger.h"
 #include "debug_sync.h"
 
+#ifdef  __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+extern void * (*governor_load_lve_library)();
+extern int (*governor_init_lve)();
+extern void (*governor_destroy_lve)();
+extern int (*governor_enter_lve)(uint32_t *, char *);
+extern int (*governor_enter_lve_light)(uint32_t *);
+extern void (*governor_lve_exit)(uint32_t *);
+
+#ifdef  __cplusplus
+}
+#endif
+
 /**
   @defgroup Runtime_Environment Runtime Environment
   @{
@@ -1761,6 +1776,45 @@
   DBUG_VOID_RETURN;
 }
 
+void set_governor_variable(){
+	governor_get_command = 1;
+}
+
+void set_governor_variable_reconn(){
+	governor_get_command = 1;
+	if(close_sock){
+	     (*close_sock)();
+	}
+	if(connect_to_server){
+	     if(!(*connect_to_server)()){
+	             sql_print_information("Governor reconnected");
+	     } else {
+	             sql_print_error("Governor not reconnected. Failed connection");
+	     }
+	}
+}
+
+void set_governor_variable_lve(){
+	if(!governor_get_command){
+		if(governor_init_lve){
+			if(governor_init_lve()){
+				sql_print_error("Governor LVE initialization error");
+			}
+		}
+	}
+	governor_get_command = 2;
+}
+
+void set_governor_variable_reconn_lve(){
+	set_governor_variable_reconn();
+	governor_get_command = 2;
+	if(governor_init_lve){
+		if(governor_init_lve()){
+			sql_print_error("Governor LVE initialization error");
+		}
+	}
+}
+
 
 /**
   Create a TABLE_LIST object for an INFORMATION_SCHEMA table.
@@ -4172,9 +4226,42 @@
 		 MYF(0));
       goto error;
     }
-    sql_kill(thd, (ulong)it->val_int(), lex->type & ONLY_KILL_QUERY);
+    
+    if(it->type()==Item::STRING_ITEM){                         
+       sql_kill_user(thd, it->val_str(0)->c_ptr(), lex->type & ONLY_KILL_QUERY);                                                                                             
+    } else {                                                         
+       sql_kill(thd, (ulong)it->val_int(), lex->type & ONLY_KILL_QUERY);                                                                                                                                                                 
+    }                                                                                                                                                     
+        
     break;
   }
+  case SQLCOM_LVECMD:
+    {
+      Item *it= (Item *)lex->value_list.head();
+
+      if (lex->table_or_sp_used())
+      {
+       my_error(ER_NOT_SUPPORTED_YET, MYF(0), "Usage of subqueries or stored "
+                 "function calls as part of this statement");
+        break;
+      }
+
+      if ((!it->fixed && it->fix_fields(lex->thd, &it)) || it->check_cols(1))
+      {
+        my_message(ER_SET_CONSTANTS_ONLY, ER(ER_SET_CONSTANTS_ONLY),
+  		 MYF(0));
+        goto error;
+      }
+
+      if(it->type()==Item::STRING_ITEM){
+         sql_kill_user_lve(thd, it->val_str(0)->c_ptr(), lex->type & ONLY_KILL_QUERY);
+      } else {
+    	  my_error(ER_NOT_SUPPORTED_YET, MYF(0), "LVE by thread ID is not supported yet");
+      }
+
+
+      break;
+    }
 #ifndef NO_EMBEDDED_ACCESS_CHECKS
   case SQLCOM_SHOW_GRANTS:
   {
@@ -6042,6 +6129,11 @@
   lex->query_tables_last= &lex->query_tables;
 }
 
+my_bool chek_governors_avaliable_command(THD *thd){
+	return (thd->lex->sql_command!=SQLCOM_ENABLE_GOVERNOR&&thd->lex->sql_command!=SQLCOM_ENABLE_RECONN_GOVERNOR
+			&&thd->lex->sql_command!=SQLCOM_ENABLE_GOVERNOR_LVE&&thd->lex->sql_command!=SQLCOM_ENABLE_RECONN_GOVERNOR_LVE)&&
+			(thd->security_ctx && thd->security_ctx->user && thd->security_ctx->user[0]);
+}
 
 /*
   When you modify mysql_parse(), you may need to mofify
@@ -6084,6 +6176,10 @@
   lex_start(thd);
   mysql_reset_thd_for_next_command(thd);
 
+  if(send_info_begin&&governor_get_command&&chek_governors_avaliable_command(thd)){
+      (*send_info_begin)(thd->security_ctx->user);
+  }
+
   if (query_cache_send_result_to_client(thd, rawbuf, length) <= 0)
   {
     LEX *lex= thd->lex;
@@ -6135,7 +6231,13 @@
             thd->server_status|= SERVER_MORE_RESULTS_EXISTS;
           }
           lex->set_trg_event_type_for_tables();
+          if(governor_enter_lve && (governor_get_command==2) && chek_governors_avaliable_command(thd)){
+              if(put_in_lve(thd->security_ctx->user)<0){
+            	  my_error(ER_GET_ERRNO, MYF(0), "Can't enter into LVE");
+              }
+          }
           mysql_execute_command(thd);
+          lve_thr_exit();
 	}
       }
     }
@@ -6164,6 +6266,10 @@
     *found_semicolon= NULL;
   }
 
+  if(send_info_end&&governor_get_command&&chek_governors_avaliable_command(thd)){
+  	  (*send_info_end)(thd->security_ctx->user);
+  }
+
   DBUG_VOID_RETURN;
 }
 
@@ -6202,7 +6308,6 @@
 #endif
 
 
-
 /**
   Store field definition for create.
 
@@ -7170,6 +7275,101 @@
  return result || (thd ? thd->killed : 0);
 }
 
+uint kill_user_thread(THD *thd, char *user, bool only_kill_query) 
+{  
+ 
+  DBUG_ENTER("kill_user_thread");
+  THD *tmp;
+  i_thd *thd_tmp;
+  I_List<i_thd> threads_tmp;
+  threads_tmp.empty();
+  uint error=0;//ER_NO_SUCH_THREAD_USER;
+  VOID(pthread_mutex_lock(&LOCK_thread_count)); // For unlink from list
+  I_List_iterator<THD> it(threads);
+  while ((tmp=it++))
+  {
+    if((tmp)&&(user)&&(tmp->user_connect)&&(tmp->user_connect->user)){
+      if (!strncmp(tmp->user_connect->user,user,16))
+      {
+        VOID(pthread_mutex_lock(&tmp->LOCK_thd_data));  // Lock from delete
+        thd_tmp = new i_thd(tmp);
+        if (thd_tmp) threads_tmp.append(thd_tmp);
+        else VOID(pthread_mutex_unlock(&tmp->LOCK_thd_data));
+      }
+    }
+  }
+  VOID(pthread_mutex_unlock(&LOCK_thread_count));
+
+  if(!threads_tmp.is_empty()){
+	  I_List_iterator<i_thd> it_tmp(threads_tmp);
+	  while ((thd_tmp=it_tmp++)){
+                  tmp=thd_tmp->ptr;
+		  if ((tmp)&&((thd->security_ctx->master_access & SUPER_ACL) ||
+		       thd->security_ctx->user_matches(tmp->security_ctx)))
+		  {
+		    tmp->awake(only_kill_query ? THD::KILL_QUERY : THD::KILL_CONNECTION);
+		  } else {
+			  error=ER_KILL_DENIED_ERROR;
+		  }
+		  VOID(pthread_mutex_unlock(&tmp->LOCK_thd_data));
+
+	  }
+	  free_list(&threads_tmp);
+	  threads_tmp.empty();
+  }
+
+  DBUG_RETURN(error);
+                                                                                                                                                      
+}
+
+uint kill_user_thread_lve(THD *thd, char *user, bool only_kill_query)
+{
+
+  DBUG_ENTER("kill_user_thread_lve");
+  THD *tmp;
+  i_thd *thd_tmp;
+  I_List<i_thd> threads_tmp;
+  threads_tmp.empty();
+  uint error=0;//ER_NO_SUCH_THREAD_USER;
+  VOID(pthread_mutex_lock(&LOCK_thread_count)); // For unlink from list
+  I_List_iterator<THD> it(threads);
+  while ((tmp=it++))
+  {
+    if((tmp)&&(user)&&(tmp->user_connect)&&(tmp->user_connect->user)){
+      if (!strncmp(tmp->user_connect->user,user,16))
+      {
+        VOID(pthread_mutex_lock(&tmp->LOCK_thd_data));  // Lock from delete
+        thd_tmp = new i_thd(tmp);
+        if (thd_tmp) threads_tmp.append(thd_tmp);
+        else VOID(pthread_mutex_unlock(&tmp->LOCK_thd_data));
+      }
+    }
+  }
+  VOID(pthread_mutex_unlock(&LOCK_thread_count));
+
+  if(!threads_tmp.is_empty()){
+	  I_List_iterator<i_thd> it_tmp(threads_tmp);
+	  while ((thd_tmp=it_tmp++)){
+                  tmp=thd_tmp->ptr;
+		  if ((tmp)&&((thd->security_ctx->master_access & SUPER_ACL) ||
+		       thd->security_ctx->user_matches(tmp->security_ctx)))
+		  {
+		    if(tmp->thread_tid_cll){
+		    	governor_setlve_mysql_thread_info(tmp->thread_tid_cll);
+		    }
+		  } else {
+			  error=ER_KILL_DENIED_ERROR;
+		  }
+		  VOID(pthread_mutex_unlock(&tmp->LOCK_thd_data));
+
+	  }
+	  free_list(&threads_tmp);
+	  threads_tmp.empty();
+  }
+
+  DBUG_RETURN(error);
+
+}
 
 /**
   kill on thread.
@@ -7256,6 +7456,33 @@
     my_error(error, MYF(0), id);
 }
 
+/*
+  kills a thread and sends response
+
+  SYNOPSIS
+    sql_kill()
+    thd			Thread class
+    id			Thread id
+    only_kill_query     Should it kill the query or the connection
+*/
+
+void sql_kill_user(THD *thd, char *user, bool only_kill_query)
+{
+  uint error;
+  if (!(error= kill_user_thread(thd, user, only_kill_query)))
+    my_ok(thd);
+  else
+    my_error(error, MYF(0), user);
+}
+
+void sql_kill_user_lve(THD *thd, char *user, bool only_kill_query)
+{
+  uint error;
+  if (!(error= kill_user_thread_lve(thd, user, only_kill_query)))
+    my_ok(thd);
+  else
+    my_error(error, MYF(0), user);
+}
 
 /** If pointer is not a null pointer, append filename to it. */
 
diff -Naur a/sql/sql_prepare.cc b/sql/sql_prepare.cc
--- a/sql/sql_prepare.cc	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/sql_prepare.cc	2014-10-08 10:33:55.315595964 +0300
@@ -2011,6 +2011,7 @@
   case SQLCOM_GRANT:
   case SQLCOM_REVOKE:
   case SQLCOM_KILL:
+  case SQLCOM_LVECMD:
     break;
 
   case SQLCOM_PREPARE:
diff -Naur a/sql/sql_select.cc b/sql/sql_select.cc
--- a/sql/sql_select.cc	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/sql_select.cc	2014-10-08 10:33:55.348596110 +0300
@@ -10995,6 +10995,7 @@
 
   save_proc_info=thd->proc_info;
   thd_proc_info(thd, "converting HEAP to MyISAM");
+  my_reserve_slot();
 
   if (create_myisam_tmp_table(&new_table, param,
 			      thd->lex->select_lex.options | thd->options))
@@ -11060,10 +11061,12 @@
   if (save_proc_info)
     thd_proc_info(thd, (!strcmp(save_proc_info,"Copying to tmp table") ?
                   "Copying to tmp table on disk" : save_proc_info));
+  my_release_slot();
   DBUG_RETURN(0);
 
  err:
   DBUG_PRINT("error",("Got error: %d",write_err));
+  my_release_slot();
   table->file->print_error(write_err, MYF(0));
   (void) table->file->ha_rnd_end();
   (void) new_table.file->close();
diff -Naur a/sql/sql_yacc.yy b/sql/sql_yacc.yy
--- a/sql/sql_yacc.yy	2013-11-04 20:52:27.000000000 +0200
+++ b/sql/sql_yacc.yy	2014-10-08 10:33:55.373596220 +0300
@@ -834,6 +834,10 @@
 %token  ELSE                          /* SQL-2003-R */
 %token  ELSEIF_SYM
 %token  ENABLE_SYM
+%token  ENABLE_GOVERNOR_SYM
+%token  ENABLE_GOVERNOR_RECONN_SYM
+%token  ENABLE_GOVERNOR_LVE_SYM
+%token  ENABLE_GOVERNOR_RECONN_LVE_SYM
 %token  ENCLOSED
 %token  END                           /* SQL-2003-R */
 %token  ENDS_SYM
@@ -960,6 +964,7 @@
 %token  LOOP_SYM
 %token  LOW_PRIORITY
 %token  LT                            /* OPERATOR */
+%token  LVECMD_SYM
 %token  MASTER_CONNECT_RETRY_SYM
 %token  MASTER_HOST_SYM
 %token  MASTER_LOG_FILE_SYM
@@ -1423,7 +1428,7 @@
         reset purge begin commit rollback savepoint release
         slave master_def master_defs master_file_def slave_until_opts
         repair restore backup analyze check start checksum
-        field_list field_list_item field_spec kill column_def key_def
+        field_list field_list_item field_spec kill lvecmd column_def key_def
         keycache_list assign_to_keycache preload_list preload_keys
         select_item_list select_item values_list no_braces
         opt_limit_clause delete_limit_clause fields opt_values values
@@ -1585,6 +1590,10 @@
         | describe
         | do
         | drop
+        | enable_governor
+        | enable_governor_reconn
+        | enable_governor_lve
+        | enable_governor_reconn_lve
         | execute
         | flush
         | grant
@@ -1595,6 +1604,7 @@
         | kill
         | load
         | lock
+        | lvecmd
         | optimize
         | keycache
         | partition_entry
@@ -6475,6 +6485,20 @@
         | CHANGED             { Lex->check_opt.flags|= T_CHECK_ONLY_CHANGED; }
         | FOR_SYM UPGRADE_SYM { Lex->check_opt.sql_flags|= TT_FOR_UPGRADE; }
         ;
+        
+lvecmd:
+          LVECMD_SYM lvecmd_option expr
+          {
+            LEX *lex=Lex;
+            lex->value_list.empty();
+            lex->value_list.push_front($3);
+            lex->sql_command= SQLCOM_LVECMD;
+          }
+        ;
+
+lvecmd_option:
+          /* empty */ { Lex->type= ONLY_KILL_QUERY; }
+        ;
 
 optimize:
           OPTIMIZE opt_no_write_to_binlog table_or_tables
@@ -10108,6 +10132,41 @@
       Lex->profile_query_id= atoi($3.str);
     }
   ;
+  
+enable_governor:
+          ENABLE_GOVERNOR_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_GOVERNOR;
+            set_governor_variable();
+          }
+         ;
+
+enable_governor_reconn:
+          ENABLE_GOVERNOR_RECONN_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_RECONN_GOVERNOR;
+            set_governor_variable_reconn();
+          }
+         ;
+enable_governor_lve:
+          ENABLE_GOVERNOR_LVE_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_GOVERNOR_LVE;
+            set_governor_variable_lve();
+          }
+         ;
+
+enable_governor_reconn_lve:
+          ENABLE_GOVERNOR_RECONN_LVE_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_RECONN_GOVERNOR_LVE;
+            set_governor_variable_reconn_lve();
+          }
+         ;
 
 /* Show things */
 
diff -Naur a/storage/innobase/os/os0file.c b/storage/innobase/os/os0file.c
--- a/storage/innobase/os/os0file.c	2013-11-04 20:52:27.000000000 +0200
+++ b/storage/innobase/os/os0file.c	2014-10-08 10:33:55.398596331 +0300
@@ -3278,6 +3278,7 @@
 
 	struct aiocb*	control;
 #endif
+    my_reserve_slot();
 
 loop:
 	os_mutex_enter(array->mutex);
@@ -3371,6 +3372,7 @@
 	os_aio_array_t*	array,	/* in: aio array */
 	os_aio_slot_t*	slot)	/* in: pointer to slot */
 {
+    my_release_slot();
 	ut_ad(array);
 	ut_ad(slot);
 
diff -Naur a/storage/innobase/srv/srv0srv.c b/storage/innobase/srv/srv0srv.c
--- a/storage/innobase/srv/srv0srv.c	2013-11-04 20:52:27.000000000 +0200
+++ b/storage/innobase/srv/srv0srv.c	2014-10-08 10:33:55.420596428 +0300
@@ -1013,6 +1013,7 @@
 	ibool			has_slept = FALSE;
 	srv_conc_slot_t*	slot	  = NULL;
 	ulint			i;
+    my_reserve_slot();
 
 	if (trx->mysql_thd != NULL
 	    && thd_is_replication_slave_thread(trx->mysql_thd)) {
@@ -1171,6 +1172,7 @@
 	trx_t*	trx)	/* in: transaction object associated with the
 			thread */
 {
+	my_reserve_slot();
 	if (UNIV_LIKELY(!srv_thread_concurrency)) {
 
 		return;
@@ -1198,6 +1200,7 @@
 			thread */
 {
 	srv_conc_slot_t*	slot	= NULL;
+    my_release_slot();
 
 	if (trx->mysql_thd != NULL
 	    && thd_is_replication_slave_thread(trx->mysql_thd)) {
@@ -1253,6 +1256,7 @@
 	trx_t*	trx)	/* in: transaction object associated with the
 			thread */
 {
+    my_release_slot();
 	if (trx->n_tickets_to_enter_innodb > 0) {
 		/* We will pretend the thread is still inside InnoDB though it
 		now leaves the InnoDB engine. In this way we save
diff -Naur a/support-files/mysql.server.sh b/support-files/mysql.server.sh
--- a/support-files/mysql.server.sh	2013-11-04 20:52:27.000000000 +0200
+++ b/support-files/mysql.server.sh	2014-10-08 10:33:55.443596529 +0300
@@ -46,6 +46,21 @@
 basedir=
 datadir=
 
+if [ -e /usr/share/lve/dbgovernor/utils/mysql_export ]; then
+. /usr/share/lve/dbgovernor/utils/mysql_export
+else
+get_limit(){
+    return
+}
+set_big_limit(){
+    return
+}
+set_old_limit(){
+    return
+}
+fi
+
+
 # Default value, in seconds, afterwhich the script should timeout waiting
 # for server start. 
 # Value here is overriden by value in my.cnf. 
@@ -344,6 +359,10 @@
   'stop')
     # Stop daemon. We use a signal here to avoid having to know the
     # root password.
+    get_limit
+    set_big_limit
+    sleep 2
+    
 
     # The RedHat / SuSE lock directory to remove
     lock_dir=/var/lock/subsys/mysqlmanager
@@ -375,10 +394,12 @@
       then
         rm -f $lock_dir
       fi
+      set_old_limit
       exit $return_value
     else
       log_failure_msg "MySQL manager or server PID file could not be found!"
     fi
+    set_old_limit
     ;;
 
   'restart')
@@ -393,14 +414,20 @@
     ;;
 
   'reload'|'force-reload')
+    get_limit
+    set_big_limit
+    sleep 2
+    
     if test -s "$server_pid_file" ; then
       read mysqld_pid <  $server_pid_file
       kill -HUP $mysqld_pid && log_success_msg "Reloading service MySQL"
       touch $server_pid_file
     else
       log_failure_msg "MySQL PID file could not be found!"
+      set_old_limit
       exit 1
     fi
+    set_old_limit
     ;;
   'status')
     # First, check to see if pid file exists
