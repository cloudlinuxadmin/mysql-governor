diff --git a/include/Makefile.am b/include/Makefile.am
index f97014b..706676f 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -25,7 +25,7 @@ pkginclude_HEADERS =	$(HEADERS_ABI) my_dbug.h m_string.h my_sys.h \
 			decimal.h errmsg.h my_global.h my_net.h \
 			my_getopt.h sslopt-longopts.h my_dir.h \
 			sslopt-vars.h sslopt-case.h sql_common.h keycache.h \
-			m_ctype.h my_attribute.h $(HEADERS_GEN)
+			m_ctype.h my_attribute.h governor.h $(HEADERS_GEN)
 noinst_HEADERS =	config-win.h config-netware.h \
 			heap.h my_bitmap.h\
 			myisam.h myisampack.h myisammrg.h ft_global.h\
diff --git a/include/Makefile.in b/include/Makefile.in
index 08065dd..27b22b1 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -371,7 +371,7 @@ pkginclude_HEADERS = $(HEADERS_ABI) my_dbug.h m_string.h my_sys.h \
 			decimal.h errmsg.h my_global.h my_net.h \
 			my_getopt.h sslopt-longopts.h my_dir.h \
 			sslopt-vars.h sslopt-case.h sql_common.h keycache.h \
-			m_ctype.h my_attribute.h $(HEADERS_GEN)
+			m_ctype.h my_attribute.h governor.h $(HEADERS_GEN)
 
 noinst_HEADERS = config-win.h config-netware.h \
 			heap.h my_bitmap.h\
diff --git a/include/governor.h b/include/governor.h
new file mode 100644
index 0000000..d9a8ce8
--- /dev/null
+++ b/include/governor.h
@@ -0,0 +1,14 @@
+/*
+ * governor_pthread_wrapper.h
+ *
+ *  Created on: Sep 26, 2012
+ *      Author: alexey
+ */
+
+#ifndef GOVERNOR_PTHREAD_WRAPPER_H_
+#define GOVERNOR_PTHREAD_WRAPPER_H_
+
+#include <stdint.h>
+
+
+#endif /* GOVERNOR_PTHREAD_WRAPPER_H_ */
diff --git a/include/my_pthread.h b/include/my_pthread.h
index 51202d6..6e58e80 100644
--- a/include/my_pthread.h
+++ b/include/my_pthread.h
@@ -263,6 +263,7 @@ extern int my_sigwait(const sigset_t *set,int *sig);
 #include <signal.h>
 #undef sigwait
 #endif
+#include <governor.h>
 #include <pthread.h>
 #ifndef _REENTRANT
 #define _REENTRANT
@@ -587,6 +588,14 @@ void safe_mutex_end(FILE *file);
 
 	/* Wrappers if safe mutex is actually used */
 #ifdef SAFE_MUTEX
+
+int put_in_lve(char *user);
+void lve_thr_exit();
+void governor_setlve_mysql_thread_info(pid_t thread_id);
+void governor_detroy_mysql_thread_info();
+__attribute__((noinline)) void my_release_slot();
+__attribute__((noinline)) void my_reserve_slot();
+
 #undef pthread_mutex_init
 #undef pthread_mutex_lock
 #undef pthread_mutex_unlock
@@ -616,6 +625,22 @@ void safe_mutex_end(FILE *file);
 #define safe_mutex_assert_not_owner(mp)
 #endif /* SAFE_MUTEX */
 
+#if !defined(SAFE_MUTEX)
+
+int put_in_lve(char *user);
+void lve_thr_exit();
+void governor_setlve_mysql_thread_info(pid_t thread_id);
+void governor_detroy_mysql_thread_info();
+__attribute__ ((noinline)) int my_pthread_lvemutex_unlock(pthread_mutex_t *mutex);
+__attribute__ ((noinline)) int my_pthread_lvemutex_lock(pthread_mutex_t *mp);
+__attribute__ ((noinline)) int my_pthread_lvemutex_trylock(pthread_mutex_t *mp);
+__attribute__((noinline)) void my_release_slot();
+__attribute__((noinline)) void my_reserve_slot();
+#define pthread_mutex_lock(A) my_pthread_lvemutex_lock(A)
+#define pthread_mutex_unlock(A) my_pthread_lvemutex_unlock(A)
+#define pthread_mutex_trylock(A) my_pthread_lvemutex_trylock(A)
+#endif
+
 	/* READ-WRITE thread locking */
 
 #ifdef HAVE_BROKEN_RWLOCK			/* For OpenUnix */
diff --git a/include/mysqld_error.h b/include/mysqld_error.h
index c8e70ff..bc66502 100644
--- a/include/mysqld_error.h
+++ b/include/mysqld_error.h
@@ -482,4 +482,5 @@
 #define ER_XA_RBTIMEOUT 1478
 #define ER_XA_RBDEADLOCK 1479
 #define ER_TOO_MANY_CONCURRENT_TRXS 1480
-#define ER_ERROR_LAST 1480
+#define ER_ERROR_LAST 1481
+#define ER_NO_SUCH_THREAD_USER 1481
diff --git a/innobase/os/os0file.c b/innobase/os/os0file.c
index 8b1fbd7..c839df9 100644
--- a/innobase/os/os0file.c
+++ b/innobase/os/os0file.c
@@ -3148,6 +3148,7 @@ os_aio_array_reserve_slot(
 	struct aiocb*	control;
 #endif
 	ulint		i;
+	my_reserve_slot();
 loop:
 	os_mutex_enter(array->mutex);
 
@@ -3240,6 +3241,7 @@ os_aio_array_free_slot(
 	os_aio_array_t*	array,	/* in: aio array */
 	os_aio_slot_t*	slot)	/* in: pointer to slot */
 {
+	my_release_slot();
 	ut_ad(array);
 	ut_ad(slot);
 
diff --git a/innobase/srv/srv0srv.c b/innobase/srv/srv0srv.c
index 0974c61..009ea22 100644
--- a/innobase/srv/srv0srv.c
+++ b/innobase/srv/srv0srv.c
@@ -1002,6 +1002,7 @@ srv_conc_enter_innodb(
 	ibool			has_slept = FALSE;
 	srv_conc_slot_t*	slot	  = NULL;
 	ulint			i;
+	my_reserve_slot();
 
 	/* If trx has 'free tickets' to enter the engine left, then use one
 	such ticket */
@@ -1148,6 +1149,7 @@ srv_conc_force_enter_innodb(
 	trx_t*	trx)	/* in: transaction object associated with the
 			thread */
 {
+	my_reserve_slot();
 	if (UNIV_LIKELY(!srv_thread_concurrency)) {
 	
 		return;
@@ -1173,6 +1175,7 @@ srv_conc_force_exit_innodb(
 			thread */
 {
 	srv_conc_slot_t*	slot	= NULL;
+	my_release_slot();
 
 	if (UNIV_LIKELY(!srv_thread_concurrency)) {
 	
@@ -1226,6 +1229,7 @@ srv_conc_exit_innodb(
 	trx_t*	trx)	/* in: transaction object associated with the
 			thread */
 {
+	my_release_slot();
 	if (trx->n_tickets_to_enter_innodb > 0) {
 		/* We will pretend the thread is still inside InnoDB though it
 		now leaves the InnoDB engine. In this way we save
diff --git a/max_connection2_mysql_5_0_96_b404.patch b/max_connection2_mysql_5_0_96_b404.patch
new file mode 100644
index 0000000..fbbd2f2
diff --git a/mysys/thr_mutex.c b/mysys/thr_mutex.c
index 53ee907..1439ae4 100644
--- a/mysys/thr_mutex.c
+++ b/mysys/thr_mutex.c
@@ -21,15 +21,53 @@
 #endif
 #if defined(THREAD) && defined(SAFE_MUTEX)
 #undef SAFE_MUTEX			/* Avoid safe_mutex redefinitions */
+#define SAFE_MUTEX2
 #include "mysys_priv.h"
 #include "my_static.h"
 #include <m_string.h>
 
+void * (*governor_load_lve_library)() = NULL;
+int (*governor_init_lve)() = NULL;
+void (*governor_destroy_lve)() = NULL;
+int (*governor_enter_lve)(uint32_t *, char *) = NULL;
+void (*governor_lve_exit)(uint32_t *) = NULL;
+int (*governor_enter_lve_light)(uint32_t *) = NULL;
+void (*governor_lve_exit_null)() = NULL;
+int (*governor_lve_enter_pid)(pid_t) = NULL;
+ 
+void governor_setlve_mysql_thread_info(pid_t thread_id) {
+       thread_id = 0;
+       return;
+}
+
+__attribute__((noinline)) int put_in_lve(char *user) {
+       user = NULL;
+       return 0;
+}
+
+__attribute__((noinline)) void lve_thr_exit() {
+       return;
+}
+
+void governor_detroy_mysql_thread_info(){
+       return;
+}
+
+__attribute__((noinline)) void my_release_slot(){
+    return;
+}
+
+__attribute__((noinline)) void my_reserve_slot(){
+    return;
+}
+
+
 #ifndef DO_NOT_REMOVE_THREAD_WRAPPERS
 /* Remove wrappers */
 #undef pthread_mutex_t
 #undef pthread_mutex_init
 #undef pthread_mutex_lock
+#undef pthread_mutex_trylock
 #undef pthread_mutex_unlock
 #undef pthread_mutex_destroy
 #undef pthread_cond_wait
@@ -391,3 +429,321 @@ void safe_mutex_end(FILE *file __attribute__((unused)))
 }
 
 #endif /* THREAD && SAFE_MUTEX */
+
+
+#if defined(THREAD) && !defined(SAFE_MUTEX) && !defined(SAFE_MUTEX2)
+
+#include <linux/unistd.h>
+
+#include "mysys_priv.h"
+#include "my_static.h"
+#include <m_string.h>
+
+#include <m_ctype.h>
+#include <hash.h>
+#include <myisampack.h>
+#include <mysys_err.h>
+#include <my_sys.h>
+
+#include <governor.h>
+
+#undef pthread_mutex_lock
+#undef pthread_mutex_unlock
+#undef pthread_mutex_trylock
+
+
+void * (*governor_load_lve_library)() = NULL;
+int (*governor_init_lve)() = NULL;
+void (*governor_destroy_lve)() = NULL;
+int (*governor_enter_lve)(uint32_t *, char *) = NULL;
+void (*governor_lve_exit)(uint32_t *) = NULL;
+int (*governor_enter_lve_light)(uint32_t *) = NULL;
+void (*governor_lve_exit_null)() = NULL;
+int (*governor_lve_enter_pid)(pid_t) = NULL;
+
+extern CHARSET_INFO my_charset_latin1_bin;
+CHARSET_INFO governor_charset_bin;
+
+__thread uint32_t lve_cookie = 0;
+
+pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
+
+typedef struct __mysql_mutex {
+       pid_t *key;
+       int is_in_lve;
+       int is_in_mutex;
+       int put_in_lve;
+} mysql_mutex;
+
+static HASH *mysql_lve_mutex_governor = NULL;
+
+__thread mysql_mutex *mysql_lve_mutex_governor_ptr = 0;
+
+pthread_mutex_t mtx_mysql_lve_mutex_governor_ptr = PTHREAD_MUTEX_INITIALIZER;
+
+void governor_value_destroyed(mysql_mutex *data) {
+       free(data);
+}
+
+byte *governor_get_key_table_mutex(mysql_mutex *table_mutex, uint *length,
+               my_bool not_used __attribute__((unused))) {
+       *length = sizeof(table_mutex->key);
+       return (byte*) table_mutex->key;
+}
+
+/*
+ *   RETURN
+ * < 0 s < t
+ * 0   s == t
+ * > 0 s > t
+ */
+static int governor_my_strnncoll_8bit_bin(CHARSET_INFO * cs __attribute__((unused)),
+                                 const uchar *s, uint slen,
+                                 const uchar *t, uint tlen,
+                                 my_bool t_is_prefix){
+       int res = 0;
+       pid_t s1 = (pid_t)s, t1 = (pid_t)t;
+       if (s1 < t1)
+               res = -1;
+       else if (s1 == t1)
+               res = 0;
+       else
+               res = 1;
+       return res;
+}
+
+void governor_hash_sort_8bit_bin(CHARSET_INFO *cs __attribute__((unused)),
+		      const uchar *key, uint len,ulong *nr1, ulong *nr2)
+{
+  return;
+}
+
+HASH *governor_create_hash_table() {
+       mysql_lve_mutex_governor = (HASH *) calloc(1, sizeof(HASH));
+       if (mysql_lve_mutex_governor) {
+               memcpy(&governor_charset_bin, &my_charset_latin1_bin,
+                               sizeof(CHARSET_INFO));
+               governor_charset_bin.coll->strnncoll = governor_my_strnncoll_8bit_bin;
+               governor_charset_bin.coll->hash_sort = governor_hash_sort_8bit_bin;
+               if (hash_init(mysql_lve_mutex_governor, &governor_charset_bin, 500, 0,
+                               0, (hash_get_key) governor_get_key_table_mutex,
+                               (hash_free_key) governor_value_destroyed, 0)) {
+                       mysql_lve_mutex_governor = NULL;
+               }
+       }
+       return mysql_lve_mutex_governor;
+}
+
+int governor_add_mysql_thread_info() {
+       pid_t *buf = NULL;
+       pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+       mysql_mutex *mm = NULL;
+       if (!mysql_lve_mutex_governor) {
+               mysql_lve_mutex_governor = governor_create_hash_table();
+               if (!mysql_lve_mutex_governor){
+            	       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+                       return -1;
+        	}
+       }
+       buf = (pid_t *)syscall(__NR_gettid);
+       mm = (mysql_mutex *) hash_search(mysql_lve_mutex_governor,
+                       (byte *) buf, sizeof(buf));
+       if (!mm) {
+               mm = (mysql_mutex *) calloc(1, sizeof(mysql_mutex));
+               if (!mm)
+                       return -1;
+               mm->key = (pid_t *)syscall(__NR_gettid);
+               if (my_hash_insert(mysql_lve_mutex_governor, (byte *) mm)) {
+                       free(mm);
+                       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+                       return -1;
+               }
+       }
+       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+       mysql_lve_mutex_governor_ptr = mm;
+       return 0;
+}
+
+void governor_remove_mysql_thread_info() {
+       pid_t *buf = NULL;
+       pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+       mysql_mutex *mm = NULL;
+       if (mysql_lve_mutex_governor) {
+               buf = (pid_t *)syscall(__NR_gettid);
+               mm = (mysql_mutex *) hash_search(mysql_lve_mutex_governor,
+                               (byte *) buf, sizeof(buf));
+               if (mm)
+                       hash_delete(mysql_lve_mutex_governor, (byte *) mm);
+       }
+       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+       mysql_lve_mutex_governor_ptr = NULL;
+}
+
+void governor_setlve_mysql_thread_info(pid_t thread_id) {
+       pid_t *buf = NULL;
+       pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+       mysql_mutex *mm = NULL;
+       if (mysql_lve_mutex_governor) {
+               buf = (pid_t *)thread_id;
+               mm = (mysql_mutex *) hash_search(mysql_lve_mutex_governor,
+                               (byte *) buf, sizeof(buf));
+               if (mm) {
+                       if (!mm->is_in_lve) {
+                               mm->put_in_lve = 1;
+                               //if (mm->is_in_mutex) {
+                               //      mm->put_in_lve = 1;
+                               //} else {
+                               //      mm->put_in_lve = 1;
+                               //      governor_lve_enter_pid(thread_id);
+                               //}
+                       }
+               }
+       }
+       pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+}
+
+void governor_detroy_mysql_thread_info() {
+       if (mysql_lve_mutex_governor) {
+               pthread_mutex_lock(&mtx_mysql_lve_mutex_governor_ptr);
+               hash_free(mysql_lve_mutex_governor);
+               free(mysql_lve_mutex_governor);
+               pthread_mutex_unlock(&mtx_mysql_lve_mutex_governor_ptr);
+       }
+}
+
+__attribute__((noinline)) int put_in_lve(char *user) {
+       if (governor_add_mysql_thread_info()<0) return -1;
+       if (mysql_lve_mutex_governor_ptr) {
+               if (!governor_enter_lve(&lve_cookie, user)) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+               }
+               mysql_lve_mutex_governor_ptr->is_in_mutex = 0;
+       }
+       return 0;
+}
+
+__attribute__((noinline)) void lve_thr_exit() {
+       if (mysql_lve_mutex_governor_ptr && mysql_lve_mutex_governor_ptr->is_in_lve
+                       == 1) {
+               governor_lve_exit(&lve_cookie);
+               mysql_lve_mutex_governor_ptr->is_in_lve = 0;
+       }
+       governor_remove_mysql_thread_info();
+}
+
+__attribute__((noinline)) int my_pthread_lvemutex_lock(pthread_mutex_t *mp) {
+       if (mysql_lve_mutex_governor_ptr) {
+               if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+                       governor_lve_exit(&lve_cookie);
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+               } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve++;
+               } /*else if (mysql_lve_mutex_governor_ptr->put_in_lve
+                               && !mysql_lve_mutex_governor_ptr->is_in_mutex) {
+                       //governor_lve_exit_null();
+                       mysql_lve_mutex_governor_ptr->put_in_lve = 0;
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+               }*/
+               mysql_lve_mutex_governor_ptr->is_in_mutex++;
+       }
+       return pthread_mutex_lock(mp);
+}
+
+__attribute__((noinline)) int my_pthread_lvemutex_trylock(pthread_mutex_t *mp) {
+       if (mysql_lve_mutex_governor_ptr) {
+               if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+                       governor_lve_exit(&lve_cookie);
+               }
+       }
+       int ret = pthread_mutex_trylock(mp);
+       if (mysql_lve_mutex_governor_ptr) {
+           if (ret != EBUSY){
+                if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+                } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve++;
+                }
+                mysql_lve_mutex_governor_ptr->is_in_mutex++;
+               } else {
+                if (mysql_lve_mutex_governor_ptr->is_in_lve == 1){
+                    if (!governor_enter_lve_light(&lve_cookie)) {
+                           mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                    } else {
+            		   mysql_lve_mutex_governor_ptr->is_in_lve = 0;
+                    }
+        	}
+               }
+       }
+       return ret;
+}
+
+
+__attribute__((noinline)) int my_pthread_lvemutex_unlock(
+	   pthread_mutex_t  *mutex) {
+	   int ret = pthread_mutex_unlock(mutex);
+       if (mysql_lve_mutex_governor_ptr) {
+               if ((mysql_lve_mutex_governor_ptr->is_in_lve == 2)
+                               && governor_enter_lve_light) {
+                       if (!governor_enter_lve_light(&lve_cookie)) {
+                               mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                       }
+               } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 2) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve--;
+               }
+               mysql_lve_mutex_governor_ptr->is_in_mutex--;
+               /*if (mysql_lve_mutex_governor_ptr->put_in_lve
+                               && !mysql_lve_mutex_governor_ptr->is_in_mutex) {
+                       if (governor_enter_lve_light && !governor_enter_lve_light(
+                                       &lve_cookie)) {
+                               mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                               mysql_lve_mutex_governor_ptr->put_in_lve = 0;
+                       }
+               }*/
+       }
+       return ret;
+}
+
+__attribute__((noinline)) void my_reserve_slot() {
+       if (mysql_lve_mutex_governor_ptr) {
+               if (mysql_lve_mutex_governor_ptr->is_in_lve == 1) {
+                       governor_lve_exit(&lve_cookie);
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+               } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 1) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve++;
+               } /*else if (mysql_lve_mutex_governor_ptr->put_in_lve
+                               && !mysql_lve_mutex_governor_ptr->is_in_mutex) {
+                       //governor_lve_exit_null();
+                       mysql_lve_mutex_governor_ptr->put_in_lve = 0;
+                       mysql_lve_mutex_governor_ptr->is_in_lve = 2;
+               }*/
+               mysql_lve_mutex_governor_ptr->is_in_mutex++;
+       }
+       return;
+}
+
+__attribute__((noinline)) void my_release_slot() {
+       if (mysql_lve_mutex_governor_ptr) {
+               if ((mysql_lve_mutex_governor_ptr->is_in_lve == 2)
+                               && governor_enter_lve_light) {
+                       if (!governor_enter_lve_light(&lve_cookie)) {
+                               mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                       }
+               } else if (mysql_lve_mutex_governor_ptr->is_in_lve > 2) {
+                       mysql_lve_mutex_governor_ptr->is_in_lve--;
+               }
+               mysql_lve_mutex_governor_ptr->is_in_mutex--;
+               /*if (mysql_lve_mutex_governor_ptr->put_in_lve
+                               && !mysql_lve_mutex_governor_ptr->is_in_mutex) {
+                       if (governor_enter_lve_light && !governor_enter_lve_light(
+                                       &lve_cookie)) {
+                               mysql_lve_mutex_governor_ptr->is_in_lve = 1;
+                               mysql_lve_mutex_governor_ptr->put_in_lve = 0;
+                       }
+               }*/
+       }
+       return;
+}
+
+
+
+#endif
diff --git a/sql/handler.cc b/sql/handler.cc
index 063af19..398bd4c 100644
--- a/sql/handler.cc
+++ b/sql/handler.cc
@@ -878,6 +878,7 @@ int ha_rollback_trans(THD *thd, bool all)
 int ha_autocommit_or_rollback(THD *thd, int error)
 {
   DBUG_ENTER("ha_autocommit_or_rollback");
+  my_reserve_slot();
 #ifdef USING_TRANSACTIONS
   if (thd->transaction.stmt.nht)
   {
@@ -894,6 +895,7 @@ int ha_autocommit_or_rollback(THD *thd, int error)
     thd->variables.tx_isolation=thd->session_tx_isolation;
   }
 #endif
+  my_release_slot();
   DBUG_RETURN(error);
 }
 
diff --git a/sql/lex.h b/sql/lex.h
index 84d365a..910607d 100644
--- a/sql/lex.h
+++ b/sql/lex.h
@@ -179,6 +179,10 @@ static SYMBOL symbols[] = {
   { "ELSE",             SYM(ELSE)},
   { "ELSEIF",           SYM(ELSEIF_SYM)},
   { "ENABLE",		SYM(ENABLE_SYM)},
+  { "ENABLE_GOVERNOR",		SYM(ENABLE_GOVERNOR_SYM)},
+  { "ENABLE_GOVERNOR_RECON",		SYM(ENABLE_GOVERNOR_RECONN_SYM)},
+  { "ENABLE_GOVERNOR_LVE",             SYM(ENABLE_GOVERNOR_LVE_SYM)},
+  { "ENABLE_GOVERNOR_RECON_LVE",               SYM(ENABLE_GOVERNOR_RECONN_LVE_SYM)},
   { "ENCLOSED",		SYM(ENCLOSED)},
   { "END",		SYM(END)},
   { "ENGINE",		SYM(ENGINE_SYM)},
@@ -292,6 +296,7 @@ static SYMBOL symbols[] = {
   { "LONGTEXT",		SYM(LONGTEXT)},
   { "LOOP",             SYM(LOOP_SYM)},
   { "LOW_PRIORITY",	SYM(LOW_PRIORITY)},
+  { "LVECMD",          SYM(LVECMD_SYM)},
   { "MASTER",           SYM(MASTER_SYM)},
   { "MASTER_CONNECT_RETRY",           SYM(MASTER_CONNECT_RETRY_SYM)},
   { "MASTER_HOST",           SYM(MASTER_HOST_SYM)},
diff --git a/sql/mysql_priv.h b/sql/mysql_priv.h
index 754064a..dc6487c 100644
--- a/sql/mysql_priv.h
+++ b/sql/mysql_priv.h
@@ -86,6 +86,8 @@ char *sql_strmake_with_convert(const char *str, uint32 arg_length,
 			       CHARSET_INFO *from_cs,
 			       uint32 max_res_length,
 			       CHARSET_INFO *to_cs, uint32 *result_length);
+void kill_user_thread(THD *thd, char *user, bool only_kill_query);
+void kill_user_thread_lve(THD *thd, char *user, bool only_kill_query);
 void kill_one_thread(THD *thd, ulong id, bool only_kill_query);
 bool net_request_file(NET* net, const char* fname);
 char* query_table_status(THD *thd,const char *db,const char *table_name);
@@ -1013,6 +1015,11 @@ ST_SCHEMA_TABLE *find_schema_table(THD *thd, const char* table_name);
 ST_SCHEMA_TABLE *get_schema_table(enum enum_schema_tables schema_table_idx);
 int prepare_schema_table(THD *thd, LEX *lex, Table_ident *table_ident,
                          enum enum_schema_tables schema_table_idx);
+void set_governor_variable();
+void set_governor_variable_reconn();
+void set_governor_variable_lve();
+void set_governor_variable_reconn_lve();
+
 int make_schema_select(THD *thd,  SELECT_LEX *sel,
                        enum enum_schema_tables schema_table_idx);
 int mysql_schema_table(THD *thd, LEX *lex, TABLE_LIST *table_list);
@@ -1432,6 +1439,13 @@ extern HASH global_index_stats;
 extern pthread_mutex_t LOCK_global_index_stats;
 extern pthread_mutex_t LOCK_stats;
 
+extern volatile int governor_get_command;
+extern int (*connect_to_server)();
+extern int (*send_info_begin)(char *);
+extern int (*send_info_end)(char *);
+extern int (*close_sock)();
+extern void * governor_library_handle;
+
 extern const char *opt_date_time_formats[];
 extern KNOWN_DATE_TIME_FORMAT known_date_time_formats[];
 
@@ -1678,6 +1692,7 @@ bool flush_error_log(void);
 /* sql_list.cc */
 void free_list(I_List <i_string_pair> *list);
 void free_list(I_List <i_string> *list);
+void free_list(I_List <i_thd> *list);
 
 /* sql_yacc.cc */
 extern int MYSQLparse(void *thd);
@@ -1685,6 +1700,8 @@ extern int MYSQLparse(void *thd);
 extern void turn_parser_debug_on();
 #endif
 
+extern "C" pid_t gettid(void);
+
 /* frm_crypt.cc */
 #ifdef HAVE_CRYPTED_FRM
 SQL_CRYPT *get_crypt_for_frm(void);
diff --git a/sql/mysqld.cc b/sql/mysqld.cc
index 9f37ac5..b6d712c 100644
--- a/sql/mysqld.cc
+++ b/sql/mysqld.cc
@@ -22,6 +22,7 @@
 #include "stacktrace.h"
 #include "mysqld_suffix.h"
 #include "mysys_err.h"
+#include <dlfcn.h>
 #ifdef HAVE_BERKELEY_DB
 #include "ha_berkeley.h"
 #endif
@@ -64,6 +65,8 @@
 #include "sp_rcontext.h"
 #include "sp_cache.h"
 
+#include <linux/unistd.h>
+
 #define mysqld_charset &my_charset_latin1
 
 #ifndef DBUG_OFF
@@ -232,6 +235,10 @@ inline void setup_fpu()
 #include <my_pthread.h>			// For thr_setconcurency()
 #endif
 
+#ifndef GETTID
+pid_t gettid(void) {return syscall(__NR_gettid);}
+#endif
+
 #ifdef SOLARIS
 extern "C" int gethostname(char *name, int namelen);
 #endif
@@ -368,6 +375,30 @@ static my_bool opt_sync_bdb_logs;
 
 /* Global variables */
 
+#ifdef  __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+extern void * (*governor_load_lve_library)();
+extern int (*governor_init_lve)();
+extern void (*governor_destroy_lve)();
+extern int (*governor_enter_lve)(uint32_t *, char *);
+extern int (*governor_enter_lve_light)(uint32_t *);
+extern void (*governor_lve_exit)(uint32_t *);
+extern void (*governor_lve_exit_null)();
+extern int (*governor_lve_enter_pid)(pid_t);
+
+#ifdef  __cplusplus
+}
+#endif
+
+volatile int governor_get_command = 0;
+int (*connect_to_server)() = NULL;
+int (*send_info_begin)(char *) = NULL;
+int (*send_info_end)(char *) = NULL;
+int (*close_sock)() = NULL;
+void * governor_library_handle = NULL;
+
 bool opt_update_log, opt_bin_log;
 my_bool opt_log, opt_slow_log, opt_log_queries_not_using_indexes= 0;
 bool opt_error_log= IF_WIN(1,0);
@@ -1205,6 +1236,20 @@ void clean_up(bool print_message)
   free_global_client_stats();
   free_global_table_stats();
   free_global_index_stats();
+
+  governor_detroy_mysql_thread_info();
+
+  if(governor_destroy_lve){
+         governor_destroy_lve();
+  }
+
+  if(close_sock){
+         (*close_sock)();
+  }
+  if (governor_library_handle) {
+         dlclose(governor_library_handle);
+  }
+
 #ifdef HAVE_REPLICATION
   end_slave_list();
   free_list(&replicate_do_db);
@@ -6584,6 +6629,7 @@ struct show_var_st status_vars[]= {
   {"Com_load_master_data",     (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOAD_MASTER_DATA]), SHOW_LONG_STATUS},
   {"Com_load_master_table",    (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOAD_MASTER_TABLE]), SHOW_LONG_STATUS},
   {"Com_lock_tables",	       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LOCK_TABLES]), SHOW_LONG_STATUS},
+  {"Com_lvecmd",		       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_LVECMD]), SHOW_LONG_STATUS},
   {"Com_optimize",	       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_OPTIMIZE]), SHOW_LONG_STATUS},
   {"Com_preload_keys",	       (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PRELOAD_KEYS]), SHOW_LONG_STATUS},
   {"Com_prepare_sql",          (char*) offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_PREPARE]), SHOW_LONG_STATUS},
@@ -6655,6 +6701,7 @@ struct show_var_st status_vars[]= {
   {"Delayed_errors",           (char*) &delayed_insert_errors,  SHOW_LONG},
   {"Delayed_insert_threads",   (char*) &delayed_insert_threads, SHOW_LONG_CONST},
   {"Delayed_writes",           (char*) &delayed_insert_writes,  SHOW_LONG},
+  {"Enable_governor",           (char*) &governor_get_command,  SHOW_INT}, 
   {"Flush_commands",           (char*) &refresh_version,        SHOW_LONG_CONST},
   {"Handler_commit",           (char*) offsetof(STATUS_VAR, ha_commit_count), SHOW_LONG_STATUS},
   {"Handler_delete",           (char*) offsetof(STATUS_VAR, ha_delete_count), SHOW_LONG_STATUS},
@@ -6814,6 +6861,24 @@ To see what values a running MySQL server is using, type\n\
   }
 }
 
+void governor_set_fn_ptr_to_null(){
+       governor_load_lve_library = NULL;
+       governor_init_lve = NULL;
+       governor_destroy_lve = NULL;
+       governor_enter_lve = NULL;
+       governor_lve_exit = NULL;
+       governor_enter_lve_light = NULL;
+       governor_lve_exit_null = NULL;
+       governor_lve_enter_pid = NULL;
+}
+
+void governor_set_fn2_ptr_to_null(){
+       connect_to_server = NULL;
+       send_info_begin = NULL;
+       send_info_end = NULL;
+       close_sock = NULL;
+}
+
 
 /*
   Initialize all MySQL global variables to default values
@@ -6952,6 +7017,115 @@ static void mysql_init_variables(void)
   max_system_variables.max_join_size=   (ulonglong) HA_POS_ERROR;
   global_system_variables.old_passwords= 0;
 
+
+ 
+
+  governor_get_command = 0;
+  connect_to_server = NULL;
+  send_info_begin = NULL;
+  send_info_end = NULL;
+  close_sock = NULL;
+  governor_library_handle = NULL;
+
+  char *error_dl = NULL;
+  governor_library_handle = dlopen("libgovernor.so", RTLD_LAZY);
+  if (governor_library_handle) {
+         sql_print_information("libgovernor.so found");
+         while(1){
+                 connect_to_server = (int (*)())dlsym(governor_library_handle, "connect_to_server");
+                 if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn2_ptr_to_null();
+                         break;
+                 }
+                 send_info_begin = (int (*)(char *))dlsym(governor_library_handle, "send_info_begin");
+                 if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn2_ptr_to_null();
+                         break;
+                 }
+                 send_info_end = (int (*)(char *))dlsym(governor_library_handle, "send_info_end");
+                 if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn2_ptr_to_null();
+                         break;
+                 }
+                 close_sock = (int (*)())dlsym(governor_library_handle, "close_sock");
+                 if ((error_dl = dlerror()) != NULL){
+                         governor_set_fn2_ptr_to_null();
+                         break;
+                 }
+                 sql_print_information("All governors functions found too");
+                 break;
+         }
+  } else {
+         sql_print_information("libgovernor.so not found");
+  }
+  if(connect_to_server){
+         if(!(*connect_to_server)()){
+                 sql_print_information("Governor connected");
+         } else {
+                 sql_print_error("Governor not connected");
+         }
+  }
+  if (governor_library_handle){
+
+         while(1){
+                 governor_load_lve_library = (void * (*)())dlsym(governor_library_handle, "governor_load_lve_library");
+                 if ((error_dl = dlerror()) != NULL){
+                       governor_set_fn_ptr_to_null();
+                       break;
+                 }
+                 governor_init_lve = (int (*)())dlsym(governor_library_handle, "governor_init_lve");
+                 if ((error_dl = dlerror()) != NULL){
+                       governor_set_fn_ptr_to_null();
+                       break;
+                 }
+                 governor_destroy_lve = (void (*)())dlsym(governor_library_handle, "governor_destroy_lve");
+                 if ((error_dl = dlerror()) != NULL){
+                       governor_set_fn_ptr_to_null();
+                   break;
+                 }
+                 governor_enter_lve = (int (*)(uint32_t *, char *))dlsym(governor_library_handle, "governor_enter_lve");
+                 if ((error_dl = dlerror()) != NULL){
+                       governor_set_fn_ptr_to_null();
+                       break;
+                 }
+
+                 governor_lve_exit = (void (*)(uint32_t *))dlsym(governor_library_handle, "governor_lve_exit");
+                 if ((error_dl = dlerror()) != NULL){
+                       governor_set_fn_ptr_to_null();
+                       break;
+                 }
+
+                 governor_enter_lve_light = (int (*)(uint32_t *))dlsym(governor_library_handle, "governor_enter_lve_light");
+                 if ((error_dl = dlerror()) != NULL){
+                       governor_set_fn_ptr_to_null();
+                       break;
+                 }
+
+                 governor_lve_exit_null = (void (*)(void))dlsym(governor_library_handle, "governor_lve_exit_null");
+                 if ((error_dl = dlerror()) != NULL){
+                       governor_set_fn_ptr_to_null();
+                       break;
+                 }
+
+                 governor_lve_enter_pid = (int (*)(pid_t))dlsym(governor_library_handle, "governor_lve_enter_pid");
+                 if ((error_dl = dlerror()) != NULL){
+                       governor_set_fn_ptr_to_null();
+                       break;
+                 }
+
+                 sql_print_information("All governors lve functions found too");
+                 break;
+          }
+
+  }
+
+  if(governor_load_lve_library){
+         if(!governor_load_lve_library()){
+                 sql_print_information("Can't get LVE functions");
+         }
+  }
+
+ 
   /*
     Default behavior for 4.1 and 5.0 is to treat NULL values as unequal
     when collecting index statistics for MyISAM tables.
@@ -7844,6 +8018,7 @@ static void set_server_version(void)
 #endif
   if (opt_log || opt_update_log || opt_slow_log || opt_bin_log)
     strmov(end, "-log");                        // This may slow down system
+  end= strmov(end, "-cll-lve");
 }
 
 
diff --git a/sql/share/errmsg.txt b/sql/share/errmsg.txt
index 2b43ba0..ae5c3e1 100644
--- a/sql/share/errmsg.txt
+++ b/sql/share/errmsg.txt
@@ -5651,3 +5651,5 @@ ER_XA_RBDEADLOCK XA102
 	eng "XA_RBDEADLOCK: Transaction branch was rolled back: deadlock was detected"
 ER_TOO_MANY_CONCURRENT_TRXS
         eng  "Too many active concurrent transactions"
+ER_NO_SUCH_THREAD_USER
+        eng "Unknown user name: %s"
diff --git a/sql/sql_acl.cc b/sql/sql_acl.cc
index ef2dbb0..86256f8 100644
--- a/sql/sql_acl.cc
+++ b/sql/sql_acl.cc
@@ -392,7 +392,7 @@ static my_bool acl_load(THD *thd, TABLE_LIST *tables)
         {
           /* Starting from 5.0.3 we have max_user_connections field */
           ptr= get_field(thd->mem_root, table->field[next_field++]);
-          user.user_resource.user_conn= ptr ? atoi(ptr) : 0;
+          user.user_resource.user_conn= ptr ? atoll(ptr) : 0;
         }
         else
           user.user_resource.user_conn= 0;
diff --git a/sql/sql_class.cc b/sql/sql_class.cc
index 8708457..8b3d421 100644
--- a/sql/sql_class.cc
+++ b/sql/sql_class.cc
@@ -197,7 +197,7 @@ THD::THD()
    m_parser_state(NULL)
 {
   ulong tmp;
-
+  thread_tid_cll = 0;
   /*
     Pass nominal parameters to init_alloc_root only to ensure that
     the destructor works OK in case of an error. The main_mem_root
@@ -478,6 +478,7 @@ void THD::update_stats(bool ran_command) {
 
 void THD::init_for_queries()
 {
+  thread_tid_cll = gettid();
   set_time(); 
   ha_enable_transaction(this,TRUE);
 
diff --git a/sql/sql_class.cc.orig b/sql/sql_class.cc.orig
index bfa5cec..8708457 100644
--- a/sql/sql_class.cc.orig
+++ b/sql/sql_class.cc.orig
@@ -239,6 +239,13 @@ THD::THD()
   bzero(ha_data, sizeof(ha_data));
   mysys_var=0;
   binlog_evt_union.do_union= FALSE;
+  busy_time = 0;
+  cpu_time = 0;
+  bytes_received = 0;
+  bytes_sent = 0;
+  binlog_bytes_written = 0;
+  updated_row_count = 0;
+  sent_row_count_2 = 0;
 #ifndef DBUG_OFF
   dbug_sentry=THD_SENTRY_MAGIC;
 #endif
@@ -378,6 +385,88 @@ void THD::init(void)
   total_warn_count= 0;
   update_charset();
   bzero((char *) &status_var, sizeof(status_var));
+  reset_stats();
+}
+
+// Resets stats in a THD.
+void THD::reset_stats(void) {
+  current_connect_time = time(NULL);
+  last_global_update_time = current_connect_time;
+  reset_diff_stats();
+}
+
+// Resets the 'diff' stats, which are used to update global stats.
+void THD::reset_diff_stats(void) {
+  diff_total_busy_time = 0;
+  diff_total_cpu_time = 0;
+  diff_total_bytes_received = 0;
+  diff_total_bytes_sent = 0;
+  diff_total_binlog_bytes_written = 0;
+  diff_total_sent_rows = 0;
+  diff_total_updated_rows = 0;
+  diff_total_read_rows = 0;
+  diff_select_commands = 0;
+  diff_update_commands = 0;
+  diff_other_commands = 0;
+  diff_commit_trans = 0;
+  diff_rollback_trans = 0;
+  diff_denied_connections = 0;
+  diff_lost_connections = 0;
+  diff_access_denied_errors = 0;
+  diff_empty_queries = 0;
+}
+
+// Updates 'diff' stats of a THD.
+void THD::update_stats(bool ran_command) {
+  if (opt_userstat_running) {
+  diff_total_busy_time += busy_time;
+  diff_total_cpu_time += cpu_time;
+  diff_total_bytes_received += bytes_received;
+  diff_total_bytes_sent += bytes_sent;
+  diff_total_binlog_bytes_written += binlog_bytes_written;
+  diff_total_sent_rows += sent_row_count_2;
+  diff_total_updated_rows += updated_row_count;
+  // diff_total_read_rows is updated in handler.cc.
+
+  if (ran_command) {
+    // The replication thread has the COM_CONNECT command.
+    if ((old_command == COM_QUERY || command == COM_CONNECT) &&
+        (lex->sql_command >= 0 && lex->sql_command < SQLCOM_END)) {
+      // A SQL query.
+      if (lex->sql_command == SQLCOM_SELECT) {
+        if (lex->orig_sql_command == SQLCOM_END) {
+          diff_select_commands++;
+          if (!sent_row_count_2)
+            diff_empty_queries++;
+        } else {
+          // 'SHOW ' commands become SQLCOM_SELECT.
+          diff_other_commands++;
+          // 'SHOW ' commands shouldn't inflate total sent row count.
+          diff_total_sent_rows -= sent_row_count_2;
+        }
+      } else if (is_update_query(lex->sql_command)) {
+        diff_update_commands++;
+      } else {
+        diff_other_commands++;
+      }
+    }
+  }
+  // diff_commit_trans is updated in handler.cc.
+  // diff_rollback_trans is updated in handler.cc.
+  // diff_denied_connections is updated in sql_parse.cc.
+  // diff_lost_connections is updated in sql_parse.cc.
+  // diff_access_denied_errors is updated in sql_parse.cc.
+
+  /* reset counters to zero to avoid double-counting since values
+     are already store in diff_total_*. */
+  }
+  busy_time = 0;
+  cpu_time = 0;
+  bytes_received = 0;
+  bytes_sent = 0;
+  binlog_bytes_written = 0;
+  updated_row_count = 0;
+  sent_row_count_2 = 0;
 }
 
 
@@ -907,6 +996,33 @@ void THD::close_active_vio()
 }
 #endif
 
+char *THD::get_client_host_port(THD *client)
+{
+  Security_context *client_sctx= client->security_ctx;
+  char *client_host= NULL;
+
+  if (client->peer_port && (client_sctx->host || client_sctx->ip) &&
+      security_ctx->host_or_ip[0])
+  {
+    if ((client_host= this->alloc(LIST_PROCESS_HOST_LEN+1)))
+      my_snprintf((char *) client_host, LIST_PROCESS_HOST_LEN,
+                  "%s:%u", client_sctx->host_or_ip, client->peer_port);
+  }
+  else
+    client_host= this->strdup(client_sctx->host_or_ip[0] ?
+                              client_sctx->host_or_ip :
+                              client_sctx->host ? client_sctx->host : "");
+
+  return client_host;
+}
+
+const char *get_client_host(THD *client)
+{
+  return client->security_ctx->host_or_ip[0] ?
+      client->security_ctx->host_or_ip :
+      client->security_ctx->host ? client->security_ctx->host : "";
+}
+
 
 struct Item_change_record: public ilink
 {
@@ -1082,6 +1198,7 @@ bool select_send::send_data(List<Item> &items)
     buffer.set(buff, sizeof(buff), &my_charset_bin);
   }
   thd->sent_row_count++;
+  thd->sent_row_count_2++;
   if (!thd->vio_ok())
     DBUG_RETURN(0);
   if (!thd->net.report_error)
@@ -1174,6 +1291,7 @@ select_to_file::~select_to_file()
 select_export::~select_export()
 {
   thd->sent_row_count=row_count;
+  thd->sent_row_count_2=row_count;
 }
 
 
@@ -2109,6 +2227,7 @@ void thd_increment_bytes_sent(ulong length)
   if (likely(thd != 0))
   { /* current_thd==0 when close_connection() calls net_send_error() */
     thd->status_var.bytes_sent+= length;
+    thd->bytes_sent+= length;
   }
 }
 
@@ -2116,6 +2235,7 @@ void thd_increment_bytes_sent(ulong length)
 void thd_increment_bytes_received(ulong length)
 {
   current_thd->status_var.bytes_received+= length;
+  current_thd->bytes_received+= length;
 }
 
 
diff --git a/sql/sql_class.h b/sql/sql_class.h
index 3aaa564..57fd45d 100644
--- a/sql/sql_class.h
+++ b/sql/sql_class.h
@@ -1467,6 +1467,7 @@ public:
   ulong      row_count;
   long	     dbug_thread_id;
   pthread_t  real_id;
+  pid_t      thread_tid_cll;
   uint	     tmp_table, global_read_lock;
   uint	     server_status,open_options,system_thread;
   uint       db_length;
@@ -2626,3 +2627,12 @@ public:
 void add_to_status(STATUS_VAR *to_var, STATUS_VAR *from_var);
 void mark_transaction_to_rollback(THD *thd, bool all);
 
+/* DB_GOVERNOR ADDITIONS */
+class i_thd: public ilink
+{
+public:
+  THD* ptr;
+  i_thd():ptr(0) { }
+  i_thd(THD* s) : ptr(s) {}
+};
+
diff --git a/sql/sql_lex.h b/sql/sql_lex.h
index 1806387..f5464aa 100644
--- a/sql/sql_lex.h
+++ b/sql/sql_lex.h
@@ -102,7 +102,8 @@ enum enum_sql_command {
   */
   // TODO(mcallaghan): update status_vars in mysqld to export these
   SQLCOM_SHOW_USER_STATS, SQLCOM_SHOW_TABLE_STATS, SQLCOM_SHOW_INDEX_STATS,
-  SQLCOM_SHOW_CLIENT_STATS,
+  SQLCOM_SHOW_CLIENT_STATS, SQLCOM_ENABLE_GOVERNOR, SQLCOM_ENABLE_RECONN_GOVERNOR,
+  SQLCOM_ENABLE_GOVERNOR_LVE, SQLCOM_ENABLE_RECONN_GOVERNOR_LVE, SQLCOM_LVECMD,
   /* This should be the last !!! */
   SQLCOM_END
 };
diff --git a/sql/sql_list.cc b/sql/sql_list.cc
index 01ab9b9..23b47d8 100644
--- a/sql/sql_list.cc
+++ b/sql/sql_list.cc
@@ -36,3 +36,10 @@ void free_list(I_List <i_string> *list)
   while ((tmp= list->get()))
     delete tmp;
 }
+
+void free_list(I_List <i_thd> *list)
+{
+  i_thd *tmp;
+  while ((tmp= list->get()))
+    delete tmp;
+}
diff --git a/sql/sql_parse.cc b/sql/sql_parse.cc
index 618076f..e30562d 100644
--- a/sql/sql_parse.cc
+++ b/sql/sql_parse.cc
@@ -13,6 +13,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
+#define HAVE_CLOCK_GETTIME 1
 #define MYSQL_LEX 1
 #include "mysql_priv.h"
 #include "sql_repl.h"
@@ -66,6 +67,21 @@
 extern "C" int gethostname(char *name, int namelen);
 #endif
 
+#ifdef  __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+extern void * (*governor_load_lve_library)();
+extern int (*governor_init_lve)();
+extern void (*governor_destroy_lve)();
+extern int (*governor_enter_lve)(uint32_t *, char *);
+extern int (*governor_enter_lve_light)(uint32_t *);
+extern void (*governor_lve_exit)(uint32_t *);
+
+#ifdef  __cplusplus
+}
+#endif
+
 #ifndef NO_EMBEDDED_ACCESS_CHECKS
 static void time_out_user_resource_limits(THD *thd, USER_CONN *uc);
 static int check_for_max_user_connections(THD *thd, USER_CONN *uc);
@@ -480,9 +496,7 @@ int check_user(THD *thd, enum enum_server_command command,
       thd->main_security_ctx.db_access=0;
 
       /* Don't allow user to connect if he has done too many queries */
-      if ((ur.questions || ur.updates || ur.conn_per_hour || ur.user_conn ||
-	   max_user_connections) &&
-	  get_or_create_user_conn(thd,
+      if (get_or_create_user_conn(thd,
             (opt_old_style_user_limits ? thd->main_security_ctx.user :
              thd->main_security_ctx.priv_user),
             (opt_old_style_user_limits ? thd->main_security_ctx.host_or_ip :
@@ -766,6 +780,9 @@ void init_global_index_stats(void)
 */
 
 #ifndef NO_EMBEDDED_ACCESS_CHECKS
+int is_root_access(char *user_name){                                                                                                                       
+    return !strcmp(user_name,"root")||!strcmp(user_name,"mysql");                                                                                          
+}  
 
 static int check_for_max_user_connections(THD *thd, USER_CONN *uc)
 {
@@ -773,6 +790,15 @@ static int check_for_max_user_connections(THD *thd, USER_CONN *uc)
   DBUG_ENTER("check_for_max_user_connections");
 
   (void) pthread_mutex_lock(&LOCK_user_conn);
+  
+  if (((uc->user_resources.user_conn==(uint)~0) || (max_user_connections == (uint)~0)) && !is_root_access(uc->user)) {
+    net_printf_error(thd, ER_USER_LIMIT_REACHED, uc->user,
+                     "max_user_connections",
+                     (long) uc->user_resources.user_conn);
+    error= 1;
+    goto end;
+  }
+  
   if (max_user_connections && !uc->user_resources.user_conn &&
       max_user_connections < (uint) uc->connections)
   {
@@ -1561,6 +1587,7 @@ void execute_init_command(THD *thd, sys_var_str *init_command_var,
 pthread_handler_t handle_one_connection(void *arg)
 {
   THD *thd=(THD*) arg;
+  thd->thread_tid_cll = gettid();
   uint launch_time  =
     (uint) ((thd->thr_create_time = time(NULL)) - thd->connect_time);
   if (launch_time >= slow_launch_time)
@@ -1857,6 +1884,47 @@ end:
   DBUG_RETURN(0);
 }
 
+void set_governor_variable(){
+	governor_get_command = 1;
+}
+
+void set_governor_variable_reconn(){
+	governor_get_command = 1;
+	if(close_sock){
+	     (*close_sock)();
+	}
+	if(connect_to_server){
+	     if(!(*connect_to_server)()){
+	             sql_print_information("Governor reconnected");
+	     } else {
+	             sql_print_error("Governor not reconnected. Failed connection");
+	     }
+	}
+}
+
+void set_governor_variable_lve(){
+       if(!governor_get_command){
+               if(governor_init_lve){
+                       if(governor_init_lve()){
+                               sql_print_error("Governor LVE initialization error");
+                       }
+               }
+       }
+       governor_get_command = 2;
+}
+
+void set_governor_variable_reconn_lve(){
+       set_governor_variable_reconn();
+       governor_get_command = 2;
+       if(governor_init_lve){
+               if(governor_init_lve()){
+                       sql_print_error("Governor LVE initialization error");
+               }
+       }
+}
+
+
+
 
 /**
    This works because items are allocated with sql_alloc().
@@ -5051,9 +5119,42 @@ end_with_restore_list:
 		 MYF(0));
       goto error;
     }
-    kill_one_thread(thd, (ulong)it->val_int(), lex->type & ONLY_KILL_QUERY);
+    if(it->type()==Item::STRING_ITEM){
+      kill_user_thread(thd, it->val_str(0)->c_ptr(), lex->type & ONLY_KILL_QUERY);
+    } else {
+      kill_one_thread(thd, (ulong)it->val_int(), lex->type & ONLY_KILL_QUERY);
+    }
+
     break;
   }
+  case SQLCOM_LVECMD:
+    {
+      Item *it= (Item *)lex->value_list.head();
+
+      if ((!it->fixed && it->fix_fields(lex->thd, &it)) || it->check_cols(1))
+      {
+        my_message(ER_SET_CONSTANTS_ONLY, ER(ER_SET_CONSTANTS_ONLY),
+                MYF(0));
+        goto error;
+      }
+
+      if(it->type()==Item::STRING_ITEM){
+    	  kill_user_thread_lve(thd, it->val_str(0)->c_ptr(), lex->type & ONLY_KILL_QUERY);
+      } else {
+         my_error(ER_NOT_SUPPORTED_YET, MYF(0), "LVE by thread ID is not supported yet");
+      }
+
+
+      break;
+    }
+  case SQLCOM_ENABLE_GOVERNOR:
+  case SQLCOM_ENABLE_RECONN_GOVERNOR:
+  case SQLCOM_ENABLE_GOVERNOR_LVE:
+  case SQLCOM_ENABLE_RECONN_GOVERNOR_LVE:
+  {
+	  send_ok(thd);
+	  break;
+  }
 #ifndef NO_EMBEDDED_ACCESS_CHECKS
   case SQLCOM_SHOW_GRANTS:
   {
@@ -6251,6 +6352,11 @@ check_access(THD *thd, ulong want_access, const char *db, ulong *save_priv,
 #endif /* NO_EMBEDDED_ACCESS_CHECKS */
 }
 
+my_bool chek_governors_avaliable_command(THD *thd){
+	return (thd->lex->sql_command!=SQLCOM_ENABLE_GOVERNOR&&thd->lex->sql_command!=SQLCOM_ENABLE_RECONN_GOVERNOR
+			&&thd->lex->sql_command!=SQLCOM_ENABLE_GOVERNOR_LVE&&thd->lex->sql_command!=SQLCOM_ENABLE_RECONN_GOVERNOR_LVE)&&
+			(thd->security_ctx && thd->security_ctx->user && thd->security_ctx->user[0]);
+}
 
 /*
   check for global access and give descriptive error message if it fails
@@ -6905,6 +7011,9 @@ void mysql_init_multi_delete(LEX *lex)
 void mysql_parse(THD *thd, char *rawbuf, uint length,
                  const char ** found_semicolon)
 {
+
+  uint32_t cookie = 0;
+
   DBUG_ENTER("mysql_parse");
 
   DBUG_EXECUTE_IF("parser_debug", turn_parser_debug_on(););
@@ -6951,8 +7060,18 @@ void mysql_parse(THD *thd, char *rawbuf, uint length,
        start_usecs = start_time.tv_sec * 1000000.0 + start_time.tv_usec;
      }
    }
+
+
+   if(send_info_begin&&governor_get_command&&chek_governors_avaliable_command(thd)){
+	(*send_info_begin)(thd->security_ctx->user);
+   }
  
+  /*if(governor_enter_lve && (governor_get_command==2) && chek_governors_avaliable_command(thd)){
+         if(thd->security_ctx && thd->security_ctx->user && thd->security_ctx->user[0])
+                 governor_enter_lve(&cookie, thd->security_ctx->user);
+  }*/
 
+ 
 
   if (query_cache_send_result_to_client(thd, rawbuf, length) <= 0)
   {
@@ -7002,7 +7121,17 @@ void mysql_parse(THD *thd, char *rawbuf, uint length,
             thd->server_status|= SERVER_MORE_RESULTS_EXISTS;
           }
           lex->set_trg_event_type_for_tables();
+          if(governor_enter_lve && (governor_get_command==2) && chek_governors_avaliable_command(thd)){
+              if(put_in_lve(thd->security_ctx->user)<0){
+                 my_error(ER_GET_ERRNO, MYF(0), "Can't enter into LVE");
+              }
+          }
+
+          
+          
+          
           mysql_execute_command(thd);
+	      lve_thr_exit();
           query_cache_end_of_result(thd);
 	}
       }
@@ -7032,6 +7161,14 @@ void mysql_parse(THD *thd, char *rawbuf, uint length,
     *found_semicolon= NULL;
   }
 
+  /*if(governor_lve_exit && (governor_get_command==2) && cookie &&chek_governors_avaliable_command(thd)){
+         governor_lve_exit(&cookie);
+  }*/
+
+  if(send_info_end&&governor_get_command&&chek_governors_avaliable_command(thd)){
+  	  (*send_info_end)(thd->security_ctx->user);
+  }
+
   if (opt_userstat_running) {
     // Gets the end time.
     if (!(end_time_error = gettimeofday(&end_time, NULL))) {
@@ -8574,6 +8711,113 @@ bool insert_precheck(THD *thd, TABLE_LIST *tables)
   DBUG_RETURN(FALSE);
 }
 
+/*
+  kill user threads
+
+  SYNOPSIS
+    kill_user_thread()
+    thd                 Thread class
+    user                User name
+
+*/
+
+void kill_user_thread(THD *thd, char *user, bool only_kill_query)
+{
+  THD *tmp;
+  i_thd *thd_tmp;
+  I_List<i_thd> threads_tmp;
+  threads_tmp.empty();
+  uint error=0;//ER_NO_SUCH_THREAD_USER;
+  VOID(pthread_mutex_lock(&LOCK_thread_count)); // For unlink from list
+  I_List_iterator<THD> it(threads);
+  while ((tmp=it++))
+  {
+    if((tmp)&&(user)&&(tmp->user_connect)&&(tmp->user_connect->user)){
+      if (!strncmp(tmp->user_connect->user,user,16))
+      {
+        VOID(pthread_mutex_lock(&tmp->LOCK_thd_data));  // Lock from delete
+        thd_tmp = new i_thd(tmp);
+        if (thd_tmp) threads_tmp.append(thd_tmp);
+        else VOID(pthread_mutex_unlock(&tmp->LOCK_thd_data));
+      }
+    }
+  }
+  VOID(pthread_mutex_unlock(&LOCK_thread_count));
+
+  if(!threads_tmp.is_empty()){
+      I_List_iterator<i_thd> it_tmp(threads_tmp);
+	  while ((thd_tmp=it_tmp++)){
+                  tmp=thd_tmp->ptr;
+		  if ((tmp)&&((thd->security_ctx->master_access & SUPER_ACL) ||
+		       thd->security_ctx->user_matches(tmp->security_ctx)))
+		  {
+		    tmp->awake(only_kill_query ? THD::KILL_QUERY : THD::KILL_CONNECTION);
+		  } else {
+			  error=ER_KILL_DENIED_ERROR;
+		  }
+		  VOID(pthread_mutex_unlock(&tmp->LOCK_thd_data));
+
+	  }
+	  free_list(&threads_tmp);
+	  threads_tmp.empty();
+  }
+
+  if (!error)
+    send_ok(thd);
+  else
+    my_error(error, MYF(0), user);
+}
+
+void kill_user_thread_lve(THD *thd, char *user, bool only_kill_query)
+{
+
+  DBUG_ENTER("kill_user_thread_lve");
+  THD *tmp;
+  i_thd *thd_tmp;
+  I_List<i_thd> threads_tmp;
+  threads_tmp.empty();
+  uint error=0;//ER_NO_SUCH_THREAD_USER;
+  VOID(pthread_mutex_lock(&LOCK_thread_count)); // For unlink from list
+  I_List_iterator<THD> it(threads);
+  while ((tmp=it++))
+  {
+    if((tmp)&&(user)&&(tmp->user_connect)&&(tmp->user_connect->user)){
+      if (!strncmp(tmp->user_connect->user,user,16))
+      {
+        VOID(pthread_mutex_lock(&tmp->LOCK_thd_data));  // Lock from delete
+        thd_tmp = new i_thd(tmp);
+        if (thd_tmp) threads_tmp.append(thd_tmp);
+        else VOID(pthread_mutex_unlock(&tmp->LOCK_thd_data));
+      }
+    }
+  }
+  VOID(pthread_mutex_unlock(&LOCK_thread_count));
+
+  if(!threads_tmp.is_empty()){
+         I_List_iterator<i_thd> it_tmp(threads_tmp);
+         while ((thd_tmp=it_tmp++)){
+                  tmp=thd_tmp->ptr;
+                 if ((tmp)&&((thd->security_ctx->master_access & SUPER_ACL) ||
+                      thd->security_ctx->user_matches(tmp->security_ctx)))
+                 {
+                   if(tmp->thread_tid_cll){
+                       governor_setlve_mysql_thread_info(tmp->thread_tid_cll);
+                   }
+                 } else {
+                         error=ER_KILL_DENIED_ERROR;
+                 }
+                 VOID(pthread_mutex_unlock(&tmp->LOCK_thd_data));
+
+         }
+         free_list(&threads_tmp);
+         threads_tmp.empty();
+  }
+
+}
+
+
+
+
 
 /**
    @brief  Check privileges for SHOW CREATE TABLE statement.
diff --git a/sql/sql_select.cc b/sql/sql_select.cc
index 42aa2f6..51eb496 100644
--- a/sql/sql_select.cc
+++ b/sql/sql_select.cc
@@ -10455,6 +10455,7 @@ bool create_myisam_from_heap(THD *thd, TABLE *table, TMP_TABLE_PARAM *param,
 
   save_proc_info=thd->proc_info;
   thd_proc_info(thd, "converting HEAP to MyISAM");
+  my_reserve_slot();
 
   if (create_myisam_tmp_table(&new_table,param,
 			      thd->lex->select_lex.options | thd->options))
@@ -10511,10 +10512,12 @@ bool create_myisam_from_heap(THD *thd, TABLE *table, TMP_TABLE_PARAM *param,
   if (save_proc_info)
     thd_proc_info(thd, (!strcmp(save_proc_info,"Copying to tmp table") ?
                   "Copying to tmp table on disk" : save_proc_info));
+  my_release_slot();
   DBUG_RETURN(0);
 
  err:
   DBUG_PRINT("error",("Got error: %d",write_err));
+  my_release_slot();
   table->file->print_error(write_err, MYF(0));
   (void) table->file->ha_rnd_end();
   (void) new_table.file->close();
diff --git a/sql/sql_yacc.yy b/sql/sql_yacc.yy
index 86774b1..a6c34b0 100644
--- a/sql/sql_yacc.yy
+++ b/sql/sql_yacc.yy
@@ -636,6 +636,10 @@ bool my_yyoverflow(short **a, YYSTYPE **b, ulong *yystacksize);
 %token  ELSEIF_SYM
 %token  ELT_FUNC
 %token  ENABLE_SYM
+%token  ENABLE_GOVERNOR_SYM
+%token  ENABLE_GOVERNOR_RECONN_SYM
+%token  ENABLE_GOVERNOR_LVE_SYM
+%token  ENABLE_GOVERNOR_RECONN_LVE_SYM
 %token  ENCLOSED
 %token  ENCODE_SYM
 %token  ENCRYPT
@@ -771,6 +775,7 @@ bool my_yyoverflow(short **a, YYSTYPE **b, ulong *yystacksize);
 %token  LOOP_SYM
 %token  LOW_PRIORITY
 %token  LT
+%token  LVECMD_SYM
 %token  MAKE_SET_SYM
 %token  MASTER_CONNECT_RETRY_SYM
 %token  MASTER_HOST_SYM
@@ -1206,7 +1211,7 @@ bool my_yyoverflow(short **a, YYSTYPE **b, ulong *yystacksize);
 	reset purge begin commit rollback savepoint release
 	slave master_def master_defs master_file_def slave_until_opts
 	repair restore backup analyze check start checksum
-	field_list field_list_item field_spec kill column_def key_def
+	field_list field_list_item field_spec kill lvecmd column_def key_def
 	keycache_list assign_to_keycache preload_list preload_keys
 	select_item_list select_item values_list no_braces
 	opt_limit_clause delete_limit_clause fields opt_values values
@@ -1328,6 +1333,10 @@ statement:
 	| describe
 	| do
 	| drop
+        | enable_governor
+        | enable_governor_reconn
+        | enable_governor_lve
+        | enable_governor_reconn_lve
         | execute
 	| flush
 	| grant
@@ -1337,6 +1346,7 @@ statement:
 	| kill
 	| load
 	| lock
+	| lvecmd
 	| optimize
         | keycache
 	| preload
@@ -4254,6 +4264,21 @@ mi_check_type:
 	| CHANGED  { Lex->check_opt.flags|= T_CHECK_ONLY_CHANGED; }
         | FOR_SYM UPGRADE_SYM { Lex->check_opt.sql_flags|= TT_FOR_UPGRADE; };
 
+        
+lvecmd:
+          LVECMD_SYM lvecmd_option expr
+          {
+            LEX *lex=Lex;
+            lex->value_list.empty();
+            lex->value_list.push_front($3);
+            lex->sql_command= SQLCOM_LVECMD;
+          }
+        ;
+
+lvecmd_option:
+          /* empty */ { Lex->type= ONLY_KILL_QUERY; }
+        ;
+
 optimize:
 	OPTIMIZE opt_no_write_to_binlog table_or_tables
 	{
@@ -8049,6 +8074,43 @@ opt_profile_args:
       Lex->profile_query_id= atoi($3.str);
     }
   ;
+  
+enable_governor:
+          ENABLE_GOVERNOR_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_GOVERNOR;
+            set_governor_variable();
+          }
+         ;
+
+enable_governor_reconn:
+          ENABLE_GOVERNOR_RECONN_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_RECONN_GOVERNOR;
+            set_governor_variable_reconn();
+          }
+         ;
+         
+enable_governor_lve:
+          ENABLE_GOVERNOR_LVE_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_GOVERNOR_LVE;
+            set_governor_variable_lve();
+          }
+         ;
+
+enable_governor_reconn_lve:
+          ENABLE_GOVERNOR_RECONN_LVE_SYM
+          {
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_ENABLE_RECONN_GOVERNOR_LVE;
+            set_governor_variable_reconn_lve();
+          }
+         ;
+
 
 /* Show things */
 
diff --git a/support-files/mysql.server.sh b/support-files/mysql.server.sh
index ac7a9c2..5ac80c2 100644
--- a/support-files/mysql.server.sh
+++ b/support-files/mysql.server.sh
@@ -46,6 +46,33 @@
 basedir=
 datadir=
 
+cpu_limit=
+io_limit=
+
+get_limit(){
+  if [ -e /usr/sbin/lvectl ]; then
+        LVE_VER=`/usr/sbin/lvectl --lve-version`
+        if [ "$LVE_VER" == "4" ]; then
+            io_limit=`/usr/sbin/lvectl limits 3 | awk 'NR == 2' | awk '{print $6}'`
+        else
+            io_limit=`/usr/sbin/lvectl limits 3 | awk 'NR == 2' | awk '{print $8}'`
+        fi
+        cpu_limit=`/usr/sbin/lvectl limits 3 | awk 'NR == 2' | awk '{print $2}'`
+  fi
+}
+
+set_big_limit(){
+    if [ -e /usr/sbin/lvectl ]; then
+	/usr/sbin/lvectl set 3 --cpu=100 --io=0 --save-all-parameters
+    fi
+}
+
+set_old_limit(){
+    if [ -e /usr/sbin/lvectl ]; then        
+	/usr/sbin/lvectl set 3 --cpu=$cpu_limit --io=$io_limit --save-all-parameters
+    fi
+}
+
 # Default value, in seconds, afterwhich the script should timeout waiting
 # for server start. 
 # Value here is overriden by value in my.cnf. 
@@ -341,6 +368,10 @@ case "$mode" in
   'stop')
     # Stop daemon. We use a signal here to avoid having to know the
     # root password.
+    get_limit
+    set_big_limit
+    sleep 2
+    
 
     # The RedHat / SuSE lock directory to remove
     lock_dir=/var/lock/subsys/mysqlmanager
@@ -365,10 +396,12 @@ case "$mode" in
       then
         rm -f $lock_dir
       fi
+      set_old_limit
       exit $return_value
     else
       log_failure_msg "MySQL manager or server PID file could not be found!"
     fi
+    set_old_limit
     ;;
 
   'restart')
@@ -383,14 +416,20 @@ case "$mode" in
     ;;
 
   'reload'|'force-reload')
+    get_limit
+    set_big_limit
+    sleep 2
+    
     if test -s "$server_pid_file" ; then
       read mysqld_pid <  $server_pid_file
       kill -HUP $mysqld_pid && log_success_msg "Reloading service MySQL"
       touch $server_pid_file
     else
       log_failure_msg "MySQL PID file could not be found!"
+      set_old_limit
       exit 1
     fi
+    set_old_limit
     ;;
   'status')
     # First, check to see if pid file exists
